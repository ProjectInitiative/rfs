// This file is generated by rust-protobuf 3.1.0. Do not edit
// .proto file is parsed by protoc 3.19.4
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `filer.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_1_0;

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LookupDirectoryEntryRequest)
pub struct LookupDirectoryEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LookupDirectoryEntryRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.LookupDirectoryEntryRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LookupDirectoryEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LookupDirectoryEntryRequest {
    fn default() -> &'a LookupDirectoryEntryRequest {
        <LookupDirectoryEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl LookupDirectoryEntryRequest {
    pub fn new() -> LookupDirectoryEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &LookupDirectoryEntryRequest| { &m.directory },
            |m: &mut LookupDirectoryEntryRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &LookupDirectoryEntryRequest| { &m.name },
            |m: &mut LookupDirectoryEntryRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LookupDirectoryEntryRequest>(
            "LookupDirectoryEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LookupDirectoryEntryRequest {
    const NAME: &'static str = "LookupDirectoryEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LookupDirectoryEntryRequest {
        LookupDirectoryEntryRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LookupDirectoryEntryRequest {
        static instance: LookupDirectoryEntryRequest = LookupDirectoryEntryRequest {
            directory: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LookupDirectoryEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LookupDirectoryEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LookupDirectoryEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LookupDirectoryEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LookupDirectoryEntryResponse)
pub struct LookupDirectoryEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LookupDirectoryEntryResponse.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LookupDirectoryEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LookupDirectoryEntryResponse {
    fn default() -> &'a LookupDirectoryEntryResponse {
        <LookupDirectoryEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl LookupDirectoryEntryResponse {
    pub fn new() -> LookupDirectoryEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &LookupDirectoryEntryResponse| { &m.entry },
            |m: &mut LookupDirectoryEntryResponse| { &mut m.entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LookupDirectoryEntryResponse>(
            "LookupDirectoryEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LookupDirectoryEntryResponse {
    const NAME: &'static str = "LookupDirectoryEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LookupDirectoryEntryResponse {
        LookupDirectoryEntryResponse::new()
    }

    fn clear(&mut self) {
        self.entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LookupDirectoryEntryResponse {
        static instance: LookupDirectoryEntryResponse = LookupDirectoryEntryResponse {
            entry: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LookupDirectoryEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LookupDirectoryEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LookupDirectoryEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LookupDirectoryEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.ListEntriesRequest)
pub struct ListEntriesRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.ListEntriesRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.ListEntriesRequest.prefix)
    pub prefix: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.ListEntriesRequest.startFromFileName)
    pub startFromFileName: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.ListEntriesRequest.inclusiveStartFrom)
    pub inclusiveStartFrom: bool,
    // @@protoc_insertion_point(field:filer_pb.ListEntriesRequest.limit)
    pub limit: u32,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.ListEntriesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntriesRequest {
    fn default() -> &'a ListEntriesRequest {
        <ListEntriesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEntriesRequest {
    pub fn new() -> ListEntriesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &ListEntriesRequest| { &m.directory },
            |m: &mut ListEntriesRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "prefix",
            |m: &ListEntriesRequest| { &m.prefix },
            |m: &mut ListEntriesRequest| { &mut m.prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "startFromFileName",
            |m: &ListEntriesRequest| { &m.startFromFileName },
            |m: &mut ListEntriesRequest| { &mut m.startFromFileName },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inclusiveStartFrom",
            |m: &ListEntriesRequest| { &m.inclusiveStartFrom },
            |m: &mut ListEntriesRequest| { &mut m.inclusiveStartFrom },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ListEntriesRequest| { &m.limit },
            |m: &mut ListEntriesRequest| { &mut m.limit },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntriesRequest>(
            "ListEntriesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntriesRequest {
    const NAME: &'static str = "ListEntriesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    self.prefix = is.read_string()?;
                },
                26 => {
                    self.startFromFileName = is.read_string()?;
                },
                32 => {
                    self.inclusiveStartFrom = is.read_bool()?;
                },
                40 => {
                    self.limit = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.prefix);
        }
        if !self.startFromFileName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.startFromFileName);
        }
        if self.inclusiveStartFrom != false {
            my_size += 1 + 1;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.limit);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.prefix.is_empty() {
            os.write_string(2, &self.prefix)?;
        }
        if !self.startFromFileName.is_empty() {
            os.write_string(3, &self.startFromFileName)?;
        }
        if self.inclusiveStartFrom != false {
            os.write_bool(4, self.inclusiveStartFrom)?;
        }
        if self.limit != 0 {
            os.write_uint32(5, self.limit)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntriesRequest {
        ListEntriesRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.prefix.clear();
        self.startFromFileName.clear();
        self.inclusiveStartFrom = false;
        self.limit = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntriesRequest {
        static instance: ListEntriesRequest = ListEntriesRequest {
            directory: ::std::string::String::new(),
            prefix: ::std::string::String::new(),
            startFromFileName: ::std::string::String::new(),
            inclusiveStartFrom: false,
            limit: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntriesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntriesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntriesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntriesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.ListEntriesResponse)
pub struct ListEntriesResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.ListEntriesResponse.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.ListEntriesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntriesResponse {
    fn default() -> &'a ListEntriesResponse {
        <ListEntriesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntriesResponse {
    pub fn new() -> ListEntriesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &ListEntriesResponse| { &m.entry },
            |m: &mut ListEntriesResponse| { &mut m.entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntriesResponse>(
            "ListEntriesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntriesResponse {
    const NAME: &'static str = "ListEntriesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntriesResponse {
        ListEntriesResponse::new()
    }

    fn clear(&mut self) {
        self.entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntriesResponse {
        static instance: ListEntriesResponse = ListEntriesResponse {
            entry: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntriesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntriesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntriesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntriesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.RemoteEntry)
pub struct RemoteEntry {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.RemoteEntry.storage_name)
    pub storage_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.RemoteEntry.last_local_sync_ts_ns)
    pub last_local_sync_ts_ns: i64,
    // @@protoc_insertion_point(field:filer_pb.RemoteEntry.remote_e_tag)
    pub remote_e_tag: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.RemoteEntry.remote_mtime)
    pub remote_mtime: i64,
    // @@protoc_insertion_point(field:filer_pb.RemoteEntry.remote_size)
    pub remote_size: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.RemoteEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a RemoteEntry {
    fn default() -> &'a RemoteEntry {
        <RemoteEntry as ::protobuf::Message>::default_instance()
    }
}

impl RemoteEntry {
    pub fn new() -> RemoteEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "storage_name",
            |m: &RemoteEntry| { &m.storage_name },
            |m: &mut RemoteEntry| { &mut m.storage_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "last_local_sync_ts_ns",
            |m: &RemoteEntry| { &m.last_local_sync_ts_ns },
            |m: &mut RemoteEntry| { &mut m.last_local_sync_ts_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remote_e_tag",
            |m: &RemoteEntry| { &m.remote_e_tag },
            |m: &mut RemoteEntry| { &mut m.remote_e_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remote_mtime",
            |m: &RemoteEntry| { &m.remote_mtime },
            |m: &mut RemoteEntry| { &mut m.remote_mtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remote_size",
            |m: &RemoteEntry| { &m.remote_size },
            |m: &mut RemoteEntry| { &mut m.remote_size },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RemoteEntry>(
            "RemoteEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for RemoteEntry {
    const NAME: &'static str = "RemoteEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.storage_name = is.read_string()?;
                },
                16 => {
                    self.last_local_sync_ts_ns = is.read_int64()?;
                },
                26 => {
                    self.remote_e_tag = is.read_string()?;
                },
                32 => {
                    self.remote_mtime = is.read_int64()?;
                },
                40 => {
                    self.remote_size = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.storage_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.storage_name);
        }
        if self.last_local_sync_ts_ns != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.last_local_sync_ts_ns);
        }
        if !self.remote_e_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.remote_e_tag);
        }
        if self.remote_mtime != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.remote_mtime);
        }
        if self.remote_size != 0 {
            my_size += ::protobuf::rt::int64_size(5, self.remote_size);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.storage_name.is_empty() {
            os.write_string(1, &self.storage_name)?;
        }
        if self.last_local_sync_ts_ns != 0 {
            os.write_int64(2, self.last_local_sync_ts_ns)?;
        }
        if !self.remote_e_tag.is_empty() {
            os.write_string(3, &self.remote_e_tag)?;
        }
        if self.remote_mtime != 0 {
            os.write_int64(4, self.remote_mtime)?;
        }
        if self.remote_size != 0 {
            os.write_int64(5, self.remote_size)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> RemoteEntry {
        RemoteEntry::new()
    }

    fn clear(&mut self) {
        self.storage_name.clear();
        self.last_local_sync_ts_ns = 0;
        self.remote_e_tag.clear();
        self.remote_mtime = 0;
        self.remote_size = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static RemoteEntry {
        static instance: RemoteEntry = RemoteEntry {
            storage_name: ::std::string::String::new(),
            last_local_sync_ts_ns: 0,
            remote_e_tag: ::std::string::String::new(),
            remote_mtime: 0,
            remote_size: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for RemoteEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("RemoteEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for RemoteEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.Entry)
pub struct Entry {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.Entry.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.Entry.is_directory)
    pub is_directory: bool,
    // @@protoc_insertion_point(field:filer_pb.Entry.chunks)
    pub chunks: ::std::vec::Vec<FileChunk>,
    // @@protoc_insertion_point(field:filer_pb.Entry.attributes)
    pub attributes: ::protobuf::MessageField<FuseAttributes>,
    // @@protoc_insertion_point(field:filer_pb.Entry.extended)
    pub extended: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:filer_pb.Entry.hard_link_id)
    pub hard_link_id: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.Entry.hard_link_counter)
    pub hard_link_counter: i32,
    // @@protoc_insertion_point(field:filer_pb.Entry.content)
    pub content: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.Entry.remote_entry)
    pub remote_entry: ::protobuf::MessageField<RemoteEntry>,
    // @@protoc_insertion_point(field:filer_pb.Entry.quota)
    pub quota: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.Entry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Entry {
    fn default() -> &'a Entry {
        <Entry as ::protobuf::Message>::default_instance()
    }
}

impl Entry {
    pub fn new() -> Entry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Entry| { &m.name },
            |m: &mut Entry| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_directory",
            |m: &Entry| { &m.is_directory },
            |m: &mut Entry| { &mut m.is_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chunks",
            |m: &Entry| { &m.chunks },
            |m: &mut Entry| { &mut m.chunks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FuseAttributes>(
            "attributes",
            |m: &Entry| { &m.attributes },
            |m: &mut Entry| { &mut m.attributes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "extended",
            |m: &Entry| { &m.extended },
            |m: &mut Entry| { &mut m.extended },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hard_link_id",
            |m: &Entry| { &m.hard_link_id },
            |m: &mut Entry| { &mut m.hard_link_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hard_link_counter",
            |m: &Entry| { &m.hard_link_counter },
            |m: &mut Entry| { &mut m.hard_link_counter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "content",
            |m: &Entry| { &m.content },
            |m: &mut Entry| { &mut m.content },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, RemoteEntry>(
            "remote_entry",
            |m: &Entry| { &m.remote_entry },
            |m: &mut Entry| { &mut m.remote_entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "quota",
            |m: &Entry| { &m.quota },
            |m: &mut Entry| { &mut m.quota },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Entry>(
            "Entry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Entry {
    const NAME: &'static str = "Entry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.is_directory = is.read_bool()?;
                },
                26 => {
                    self.chunks.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.attributes)?;
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_bytes()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.extended.insert(key, value);
                },
                58 => {
                    self.hard_link_id = is.read_bytes()?;
                },
                64 => {
                    self.hard_link_counter = is.read_int32()?;
                },
                74 => {
                    self.content = is.read_bytes()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.remote_entry)?;
                },
                88 => {
                    self.quota = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.is_directory != false {
            my_size += 1 + 1;
        }
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.extended {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        if !self.hard_link_id.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.hard_link_id);
        }
        if self.hard_link_counter != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.hard_link_counter);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.content);
        }
        if let Some(v) = self.remote_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.quota != 0 {
            my_size += ::protobuf::rt::int64_size(11, self.quota);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.is_directory != false {
            os.write_bool(2, self.is_directory)?;
        }
        for v in &self.chunks {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.attributes.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for (k, v) in &self.extended {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            entry_size += ::protobuf::rt::bytes_size(2, &v);
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            os.write_bytes(2, &v)?;
        };
        if !self.hard_link_id.is_empty() {
            os.write_bytes(7, &self.hard_link_id)?;
        }
        if self.hard_link_counter != 0 {
            os.write_int32(8, self.hard_link_counter)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(9, &self.content)?;
        }
        if let Some(v) = self.remote_entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.quota != 0 {
            os.write_int64(11, self.quota)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Entry {
        Entry::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.is_directory = false;
        self.chunks.clear();
        self.attributes.clear();
        self.extended.clear();
        self.hard_link_id.clear();
        self.hard_link_counter = 0;
        self.content.clear();
        self.remote_entry.clear();
        self.quota = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Entry {
        static instance: ::protobuf::rt::Lazy<Entry> = ::protobuf::rt::Lazy::new();
        instance.get(Entry::new)
    }
}

impl ::protobuf::MessageFull for Entry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Entry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Entry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Entry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FullEntry)
pub struct FullEntry {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FullEntry.dir)
    pub dir: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FullEntry.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FullEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FullEntry {
    fn default() -> &'a FullEntry {
        <FullEntry as ::protobuf::Message>::default_instance()
    }
}

impl FullEntry {
    pub fn new() -> FullEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir",
            |m: &FullEntry| { &m.dir },
            |m: &mut FullEntry| { &mut m.dir },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &FullEntry| { &m.entry },
            |m: &mut FullEntry| { &mut m.entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FullEntry>(
            "FullEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FullEntry {
    const NAME: &'static str = "FullEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dir = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.dir.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dir);
        }
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.dir.is_empty() {
            os.write_string(1, &self.dir)?;
        }
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FullEntry {
        FullEntry::new()
    }

    fn clear(&mut self) {
        self.dir.clear();
        self.entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FullEntry {
        static instance: FullEntry = FullEntry {
            dir: ::std::string::String::new(),
            entry: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FullEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FullEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FullEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FullEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.EventNotification)
pub struct EventNotification {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.EventNotification.old_entry)
    pub old_entry: ::protobuf::MessageField<Entry>,
    // @@protoc_insertion_point(field:filer_pb.EventNotification.new_entry)
    pub new_entry: ::protobuf::MessageField<Entry>,
    // @@protoc_insertion_point(field:filer_pb.EventNotification.delete_chunks)
    pub delete_chunks: bool,
    // @@protoc_insertion_point(field:filer_pb.EventNotification.new_parent_path)
    pub new_parent_path: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.EventNotification.is_from_other_cluster)
    pub is_from_other_cluster: bool,
    // @@protoc_insertion_point(field:filer_pb.EventNotification.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.EventNotification.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventNotification {
    fn default() -> &'a EventNotification {
        <EventNotification as ::protobuf::Message>::default_instance()
    }
}

impl EventNotification {
    pub fn new() -> EventNotification {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "old_entry",
            |m: &EventNotification| { &m.old_entry },
            |m: &mut EventNotification| { &mut m.old_entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "new_entry",
            |m: &EventNotification| { &m.new_entry },
            |m: &mut EventNotification| { &mut m.new_entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "delete_chunks",
            |m: &EventNotification| { &m.delete_chunks },
            |m: &mut EventNotification| { &mut m.delete_chunks },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_parent_path",
            |m: &EventNotification| { &m.new_parent_path },
            |m: &mut EventNotification| { &mut m.new_parent_path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_from_other_cluster",
            |m: &EventNotification| { &m.is_from_other_cluster },
            |m: &mut EventNotification| { &mut m.is_from_other_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &EventNotification| { &m.signatures },
            |m: &mut EventNotification| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventNotification>(
            "EventNotification",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventNotification {
    const NAME: &'static str = "EventNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.old_entry)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.new_entry)?;
                },
                24 => {
                    self.delete_chunks = is.read_bool()?;
                },
                34 => {
                    self.new_parent_path = is.read_string()?;
                },
                40 => {
                    self.is_from_other_cluster = is.read_bool()?;
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                48 => {
                    self.signatures.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.old_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.new_entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.delete_chunks != false {
            my_size += 1 + 1;
        }
        if !self.new_parent_path.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.new_parent_path);
        }
        if self.is_from_other_cluster != false {
            my_size += 1 + 1;
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(6, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.old_entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.new_entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.delete_chunks != false {
            os.write_bool(3, self.delete_chunks)?;
        }
        if !self.new_parent_path.is_empty() {
            os.write_string(4, &self.new_parent_path)?;
        }
        if self.is_from_other_cluster != false {
            os.write_bool(5, self.is_from_other_cluster)?;
        }
        for v in &self.signatures {
            os.write_int32(6, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventNotification {
        EventNotification::new()
    }

    fn clear(&mut self) {
        self.old_entry.clear();
        self.new_entry.clear();
        self.delete_chunks = false;
        self.new_parent_path.clear();
        self.is_from_other_cluster = false;
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventNotification {
        static instance: EventNotification = EventNotification {
            old_entry: ::protobuf::MessageField::none(),
            new_entry: ::protobuf::MessageField::none(),
            delete_chunks: false,
            new_parent_path: ::std::string::String::new(),
            is_from_other_cluster: false,
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventNotification {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventNotification").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventNotification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventNotification {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FileChunk)
pub struct FileChunk {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FileChunk.file_id)
    pub file_id: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.offset)
    pub offset: i64,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.size)
    pub size: u64,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.mtime)
    pub mtime: i64,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.e_tag)
    pub e_tag: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.source_file_id)
    pub source_file_id: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.fid)
    pub fid: ::protobuf::MessageField<FileId>,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.source_fid)
    pub source_fid: ::protobuf::MessageField<FileId>,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.cipher_key)
    pub cipher_key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.is_compressed)
    pub is_compressed: bool,
    // @@protoc_insertion_point(field:filer_pb.FileChunk.is_chunk_manifest)
    pub is_chunk_manifest: bool,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FileChunk.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileChunk {
    fn default() -> &'a FileChunk {
        <FileChunk as ::protobuf::Message>::default_instance()
    }
}

impl FileChunk {
    pub fn new() -> FileChunk {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_id",
            |m: &FileChunk| { &m.file_id },
            |m: &mut FileChunk| { &mut m.file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "offset",
            |m: &FileChunk| { &m.offset },
            |m: &mut FileChunk| { &mut m.offset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "size",
            |m: &FileChunk| { &m.size },
            |m: &mut FileChunk| { &mut m.size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mtime",
            |m: &FileChunk| { &m.mtime },
            |m: &mut FileChunk| { &mut m.mtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "e_tag",
            |m: &FileChunk| { &m.e_tag },
            |m: &mut FileChunk| { &mut m.e_tag },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "source_file_id",
            |m: &FileChunk| { &m.source_file_id },
            |m: &mut FileChunk| { &mut m.source_file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FileId>(
            "fid",
            |m: &FileChunk| { &m.fid },
            |m: &mut FileChunk| { &mut m.fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, FileId>(
            "source_fid",
            |m: &FileChunk| { &m.source_fid },
            |m: &mut FileChunk| { &mut m.source_fid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cipher_key",
            |m: &FileChunk| { &m.cipher_key },
            |m: &mut FileChunk| { &mut m.cipher_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_compressed",
            |m: &FileChunk| { &m.is_compressed },
            |m: &mut FileChunk| { &mut m.is_compressed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_chunk_manifest",
            |m: &FileChunk| { &m.is_chunk_manifest },
            |m: &mut FileChunk| { &mut m.is_chunk_manifest },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileChunk>(
            "FileChunk",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileChunk {
    const NAME: &'static str = "FileChunk";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_id = is.read_string()?;
                },
                16 => {
                    self.offset = is.read_int64()?;
                },
                24 => {
                    self.size = is.read_uint64()?;
                },
                32 => {
                    self.mtime = is.read_int64()?;
                },
                42 => {
                    self.e_tag = is.read_string()?;
                },
                50 => {
                    self.source_file_id = is.read_string()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fid)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.source_fid)?;
                },
                74 => {
                    self.cipher_key = is.read_bytes()?;
                },
                80 => {
                    self.is_compressed = is.read_bool()?;
                },
                88 => {
                    self.is_chunk_manifest = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_id);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.offset);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.size);
        }
        if self.mtime != 0 {
            my_size += ::protobuf::rt::int64_size(4, self.mtime);
        }
        if !self.e_tag.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.e_tag);
        }
        if !self.source_file_id.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.source_file_id);
        }
        if let Some(v) = self.fid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_fid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.cipher_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(9, &self.cipher_key);
        }
        if self.is_compressed != false {
            my_size += 1 + 1;
        }
        if self.is_chunk_manifest != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file_id.is_empty() {
            os.write_string(1, &self.file_id)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.size != 0 {
            os.write_uint64(3, self.size)?;
        }
        if self.mtime != 0 {
            os.write_int64(4, self.mtime)?;
        }
        if !self.e_tag.is_empty() {
            os.write_string(5, &self.e_tag)?;
        }
        if !self.source_file_id.is_empty() {
            os.write_string(6, &self.source_file_id)?;
        }
        if let Some(v) = self.fid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.source_fid.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if !self.cipher_key.is_empty() {
            os.write_bytes(9, &self.cipher_key)?;
        }
        if self.is_compressed != false {
            os.write_bool(10, self.is_compressed)?;
        }
        if self.is_chunk_manifest != false {
            os.write_bool(11, self.is_chunk_manifest)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileChunk {
        FileChunk::new()
    }

    fn clear(&mut self) {
        self.file_id.clear();
        self.offset = 0;
        self.size = 0;
        self.mtime = 0;
        self.e_tag.clear();
        self.source_file_id.clear();
        self.fid.clear();
        self.source_fid.clear();
        self.cipher_key.clear();
        self.is_compressed = false;
        self.is_chunk_manifest = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileChunk {
        static instance: FileChunk = FileChunk {
            file_id: ::std::string::String::new(),
            offset: 0,
            size: 0,
            mtime: 0,
            e_tag: ::std::string::String::new(),
            source_file_id: ::std::string::String::new(),
            fid: ::protobuf::MessageField::none(),
            source_fid: ::protobuf::MessageField::none(),
            cipher_key: ::std::vec::Vec::new(),
            is_compressed: false,
            is_chunk_manifest: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileChunk {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileChunk").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileChunk {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileChunk {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FileChunkManifest)
pub struct FileChunkManifest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FileChunkManifest.chunks)
    pub chunks: ::std::vec::Vec<FileChunk>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FileChunkManifest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileChunkManifest {
    fn default() -> &'a FileChunkManifest {
        <FileChunkManifest as ::protobuf::Message>::default_instance()
    }
}

impl FileChunkManifest {
    pub fn new() -> FileChunkManifest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chunks",
            |m: &FileChunkManifest| { &m.chunks },
            |m: &mut FileChunkManifest| { &mut m.chunks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileChunkManifest>(
            "FileChunkManifest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileChunkManifest {
    const NAME: &'static str = "FileChunkManifest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.chunks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.chunks {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileChunkManifest {
        FileChunkManifest::new()
    }

    fn clear(&mut self) {
        self.chunks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileChunkManifest {
        static instance: FileChunkManifest = FileChunkManifest {
            chunks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileChunkManifest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileChunkManifest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileChunkManifest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileChunkManifest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FileId)
pub struct FileId {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FileId.volume_id)
    pub volume_id: u32,
    // @@protoc_insertion_point(field:filer_pb.FileId.file_key)
    pub file_key: u64,
    // @@protoc_insertion_point(field:filer_pb.FileId.cookie)
    pub cookie: u32,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FileId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileId {
    fn default() -> &'a FileId {
        <FileId as ::protobuf::Message>::default_instance()
    }
}

impl FileId {
    pub fn new() -> FileId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_id",
            |m: &FileId| { &m.volume_id },
            |m: &mut FileId| { &mut m.volume_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_key",
            |m: &FileId| { &m.file_key },
            |m: &mut FileId| { &mut m.file_key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cookie",
            |m: &FileId| { &m.cookie },
            |m: &mut FileId| { &mut m.cookie },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FileId>(
            "FileId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FileId {
    const NAME: &'static str = "FileId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.volume_id = is.read_uint32()?;
                },
                16 => {
                    self.file_key = is.read_uint64()?;
                },
                29 => {
                    self.cookie = is.read_fixed32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.volume_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.volume_id);
        }
        if self.file_key != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.file_key);
        }
        if self.cookie != 0 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.volume_id != 0 {
            os.write_uint32(1, self.volume_id)?;
        }
        if self.file_key != 0 {
            os.write_uint64(2, self.file_key)?;
        }
        if self.cookie != 0 {
            os.write_fixed32(3, self.cookie)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileId {
        FileId::new()
    }

    fn clear(&mut self) {
        self.volume_id = 0;
        self.file_key = 0;
        self.cookie = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileId {
        static instance: FileId = FileId {
            volume_id: 0,
            file_key: 0,
            cookie: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FileId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FuseAttributes)
pub struct FuseAttributes {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.file_size)
    pub file_size: u64,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.mtime)
    pub mtime: i64,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.file_mode)
    pub file_mode: u32,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.uid)
    pub uid: u32,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.gid)
    pub gid: u32,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.crtime)
    pub crtime: i64,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.mime)
    pub mime: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.ttl_sec)
    pub ttl_sec: i32,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.user_name)
    pub user_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.group_name)
    pub group_name: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.symlink_target)
    pub symlink_target: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.md5)
    pub md5: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.rdev)
    pub rdev: u32,
    // @@protoc_insertion_point(field:filer_pb.FuseAttributes.inode)
    pub inode: u64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FuseAttributes.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FuseAttributes {
    fn default() -> &'a FuseAttributes {
        <FuseAttributes as ::protobuf::Message>::default_instance()
    }
}

impl FuseAttributes {
    pub fn new() -> FuseAttributes {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_size",
            |m: &FuseAttributes| { &m.file_size },
            |m: &mut FuseAttributes| { &mut m.file_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mtime",
            |m: &FuseAttributes| { &m.mtime },
            |m: &mut FuseAttributes| { &mut m.mtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_mode",
            |m: &FuseAttributes| { &m.file_mode },
            |m: &mut FuseAttributes| { &mut m.file_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uid",
            |m: &FuseAttributes| { &m.uid },
            |m: &mut FuseAttributes| { &mut m.uid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "gid",
            |m: &FuseAttributes| { &m.gid },
            |m: &mut FuseAttributes| { &mut m.gid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "crtime",
            |m: &FuseAttributes| { &m.crtime },
            |m: &mut FuseAttributes| { &mut m.crtime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mime",
            |m: &FuseAttributes| { &m.mime },
            |m: &mut FuseAttributes| { &mut m.mime },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ttl_sec",
            |m: &FuseAttributes| { &m.ttl_sec },
            |m: &mut FuseAttributes| { &mut m.ttl_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "user_name",
            |m: &FuseAttributes| { &m.user_name },
            |m: &mut FuseAttributes| { &mut m.user_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "group_name",
            |m: &FuseAttributes| { &m.group_name },
            |m: &mut FuseAttributes| { &mut m.group_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symlink_target",
            |m: &FuseAttributes| { &m.symlink_target },
            |m: &mut FuseAttributes| { &mut m.symlink_target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "md5",
            |m: &FuseAttributes| { &m.md5 },
            |m: &mut FuseAttributes| { &mut m.md5 },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rdev",
            |m: &FuseAttributes| { &m.rdev },
            |m: &mut FuseAttributes| { &mut m.rdev },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "inode",
            |m: &FuseAttributes| { &m.inode },
            |m: &mut FuseAttributes| { &mut m.inode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FuseAttributes>(
            "FuseAttributes",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FuseAttributes {
    const NAME: &'static str = "FuseAttributes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_size = is.read_uint64()?;
                },
                16 => {
                    self.mtime = is.read_int64()?;
                },
                24 => {
                    self.file_mode = is.read_uint32()?;
                },
                32 => {
                    self.uid = is.read_uint32()?;
                },
                40 => {
                    self.gid = is.read_uint32()?;
                },
                48 => {
                    self.crtime = is.read_int64()?;
                },
                58 => {
                    self.mime = is.read_string()?;
                },
                80 => {
                    self.ttl_sec = is.read_int32()?;
                },
                90 => {
                    self.user_name = is.read_string()?;
                },
                98 => {
                    self.group_name.push(is.read_string()?);
                },
                106 => {
                    self.symlink_target = is.read_string()?;
                },
                114 => {
                    self.md5 = is.read_bytes()?;
                },
                128 => {
                    self.rdev = is.read_uint32()?;
                },
                136 => {
                    self.inode = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.file_size != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.file_size);
        }
        if self.mtime != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.mtime);
        }
        if self.file_mode != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.file_mode);
        }
        if self.uid != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.uid);
        }
        if self.gid != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.gid);
        }
        if self.crtime != 0 {
            my_size += ::protobuf::rt::int64_size(6, self.crtime);
        }
        if !self.mime.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.mime);
        }
        if self.ttl_sec != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.ttl_sec);
        }
        if !self.user_name.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.user_name);
        }
        for value in &self.group_name {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if !self.symlink_target.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.symlink_target);
        }
        if !self.md5.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.md5);
        }
        if self.rdev != 0 {
            my_size += ::protobuf::rt::uint32_size(16, self.rdev);
        }
        if self.inode != 0 {
            my_size += ::protobuf::rt::uint64_size(17, self.inode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.file_size != 0 {
            os.write_uint64(1, self.file_size)?;
        }
        if self.mtime != 0 {
            os.write_int64(2, self.mtime)?;
        }
        if self.file_mode != 0 {
            os.write_uint32(3, self.file_mode)?;
        }
        if self.uid != 0 {
            os.write_uint32(4, self.uid)?;
        }
        if self.gid != 0 {
            os.write_uint32(5, self.gid)?;
        }
        if self.crtime != 0 {
            os.write_int64(6, self.crtime)?;
        }
        if !self.mime.is_empty() {
            os.write_string(7, &self.mime)?;
        }
        if self.ttl_sec != 0 {
            os.write_int32(10, self.ttl_sec)?;
        }
        if !self.user_name.is_empty() {
            os.write_string(11, &self.user_name)?;
        }
        for v in &self.group_name {
            os.write_string(12, &v)?;
        };
        if !self.symlink_target.is_empty() {
            os.write_string(13, &self.symlink_target)?;
        }
        if !self.md5.is_empty() {
            os.write_bytes(14, &self.md5)?;
        }
        if self.rdev != 0 {
            os.write_uint32(16, self.rdev)?;
        }
        if self.inode != 0 {
            os.write_uint64(17, self.inode)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FuseAttributes {
        FuseAttributes::new()
    }

    fn clear(&mut self) {
        self.file_size = 0;
        self.mtime = 0;
        self.file_mode = 0;
        self.uid = 0;
        self.gid = 0;
        self.crtime = 0;
        self.mime.clear();
        self.ttl_sec = 0;
        self.user_name.clear();
        self.group_name.clear();
        self.symlink_target.clear();
        self.md5.clear();
        self.rdev = 0;
        self.inode = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FuseAttributes {
        static instance: FuseAttributes = FuseAttributes {
            file_size: 0,
            mtime: 0,
            file_mode: 0,
            uid: 0,
            gid: 0,
            crtime: 0,
            mime: ::std::string::String::new(),
            ttl_sec: 0,
            user_name: ::std::string::String::new(),
            group_name: ::std::vec::Vec::new(),
            symlink_target: ::std::string::String::new(),
            md5: ::std::vec::Vec::new(),
            rdev: 0,
            inode: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FuseAttributes {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FuseAttributes").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FuseAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FuseAttributes {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CreateEntryRequest)
pub struct CreateEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.o_excl)
    pub o_excl: bool,
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.is_from_other_cluster)
    pub is_from_other_cluster: bool,
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:filer_pb.CreateEntryRequest.skip_check_parent_directory)
    pub skip_check_parent_directory: bool,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CreateEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateEntryRequest {
    fn default() -> &'a CreateEntryRequest {
        <CreateEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateEntryRequest {
    pub fn new() -> CreateEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &CreateEntryRequest| { &m.directory },
            |m: &mut CreateEntryRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &CreateEntryRequest| { &m.entry },
            |m: &mut CreateEntryRequest| { &mut m.entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "o_excl",
            |m: &CreateEntryRequest| { &m.o_excl },
            |m: &mut CreateEntryRequest| { &mut m.o_excl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_from_other_cluster",
            |m: &CreateEntryRequest| { &m.is_from_other_cluster },
            |m: &mut CreateEntryRequest| { &mut m.is_from_other_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &CreateEntryRequest| { &m.signatures },
            |m: &mut CreateEntryRequest| { &mut m.signatures },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "skip_check_parent_directory",
            |m: &CreateEntryRequest| { &m.skip_check_parent_directory },
            |m: &mut CreateEntryRequest| { &mut m.skip_check_parent_directory },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateEntryRequest>(
            "CreateEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateEntryRequest {
    const NAME: &'static str = "CreateEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                24 => {
                    self.o_excl = is.read_bool()?;
                },
                32 => {
                    self.is_from_other_cluster = is.read_bool()?;
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                40 => {
                    self.signatures.push(is.read_int32()?);
                },
                48 => {
                    self.skip_check_parent_directory = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.o_excl != false {
            my_size += 1 + 1;
        }
        if self.is_from_other_cluster != false {
            my_size += 1 + 1;
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        if self.skip_check_parent_directory != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.o_excl != false {
            os.write_bool(3, self.o_excl)?;
        }
        if self.is_from_other_cluster != false {
            os.write_bool(4, self.is_from_other_cluster)?;
        }
        for v in &self.signatures {
            os.write_int32(5, *v)?;
        };
        if self.skip_check_parent_directory != false {
            os.write_bool(6, self.skip_check_parent_directory)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateEntryRequest {
        CreateEntryRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.entry.clear();
        self.o_excl = false;
        self.is_from_other_cluster = false;
        self.signatures.clear();
        self.skip_check_parent_directory = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateEntryRequest {
        static instance: CreateEntryRequest = CreateEntryRequest {
            directory: ::std::string::String::new(),
            entry: ::protobuf::MessageField::none(),
            o_excl: false,
            is_from_other_cluster: false,
            signatures: ::std::vec::Vec::new(),
            skip_check_parent_directory: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CreateEntryResponse)
pub struct CreateEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CreateEntryResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CreateEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CreateEntryResponse {
    fn default() -> &'a CreateEntryResponse {
        <CreateEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateEntryResponse {
    pub fn new() -> CreateEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &CreateEntryResponse| { &m.error },
            |m: &mut CreateEntryResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CreateEntryResponse>(
            "CreateEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CreateEntryResponse {
    const NAME: &'static str = "CreateEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CreateEntryResponse {
        CreateEntryResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CreateEntryResponse {
        static instance: CreateEntryResponse = CreateEntryResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CreateEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CreateEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CreateEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.UpdateEntryRequest)
pub struct UpdateEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.UpdateEntryRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.UpdateEntryRequest.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // @@protoc_insertion_point(field:filer_pb.UpdateEntryRequest.is_from_other_cluster)
    pub is_from_other_cluster: bool,
    // @@protoc_insertion_point(field:filer_pb.UpdateEntryRequest.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.UpdateEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEntryRequest {
    fn default() -> &'a UpdateEntryRequest {
        <UpdateEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEntryRequest {
    pub fn new() -> UpdateEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &UpdateEntryRequest| { &m.directory },
            |m: &mut UpdateEntryRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &UpdateEntryRequest| { &m.entry },
            |m: &mut UpdateEntryRequest| { &mut m.entry },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_from_other_cluster",
            |m: &UpdateEntryRequest| { &m.is_from_other_cluster },
            |m: &mut UpdateEntryRequest| { &mut m.is_from_other_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &UpdateEntryRequest| { &m.signatures },
            |m: &mut UpdateEntryRequest| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEntryRequest>(
            "UpdateEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEntryRequest {
    const NAME: &'static str = "UpdateEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                24 => {
                    self.is_from_other_cluster = is.read_bool()?;
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                32 => {
                    self.signatures.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.is_from_other_cluster != false {
            my_size += 1 + 1;
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(4, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.is_from_other_cluster != false {
            os.write_bool(3, self.is_from_other_cluster)?;
        }
        for v in &self.signatures {
            os.write_int32(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEntryRequest {
        UpdateEntryRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.entry.clear();
        self.is_from_other_cluster = false;
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEntryRequest {
        static instance: UpdateEntryRequest = UpdateEntryRequest {
            directory: ::std::string::String::new(),
            entry: ::protobuf::MessageField::none(),
            is_from_other_cluster: false,
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.UpdateEntryResponse)
pub struct UpdateEntryResponse {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.UpdateEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateEntryResponse {
    fn default() -> &'a UpdateEntryResponse {
        <UpdateEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateEntryResponse {
    pub fn new() -> UpdateEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateEntryResponse>(
            "UpdateEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateEntryResponse {
    const NAME: &'static str = "UpdateEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateEntryResponse {
        UpdateEntryResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateEntryResponse {
        static instance: UpdateEntryResponse = UpdateEntryResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AppendToEntryRequest)
pub struct AppendToEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.AppendToEntryRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AppendToEntryRequest.entry_name)
    pub entry_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AppendToEntryRequest.chunks)
    pub chunks: ::std::vec::Vec<FileChunk>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AppendToEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppendToEntryRequest {
    fn default() -> &'a AppendToEntryRequest {
        <AppendToEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl AppendToEntryRequest {
    pub fn new() -> AppendToEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &AppendToEntryRequest| { &m.directory },
            |m: &mut AppendToEntryRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entry_name",
            |m: &AppendToEntryRequest| { &m.entry_name },
            |m: &mut AppendToEntryRequest| { &mut m.entry_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "chunks",
            |m: &AppendToEntryRequest| { &m.chunks },
            |m: &mut AppendToEntryRequest| { &mut m.chunks },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppendToEntryRequest>(
            "AppendToEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppendToEntryRequest {
    const NAME: &'static str = "AppendToEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    self.entry_name = is.read_string()?;
                },
                26 => {
                    self.chunks.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.entry_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entry_name);
        }
        for value in &self.chunks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.entry_name.is_empty() {
            os.write_string(2, &self.entry_name)?;
        }
        for v in &self.chunks {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppendToEntryRequest {
        AppendToEntryRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.entry_name.clear();
        self.chunks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppendToEntryRequest {
        static instance: AppendToEntryRequest = AppendToEntryRequest {
            directory: ::std::string::String::new(),
            entry_name: ::std::string::String::new(),
            chunks: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppendToEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppendToEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppendToEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendToEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AppendToEntryResponse)
pub struct AppendToEntryResponse {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AppendToEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AppendToEntryResponse {
    fn default() -> &'a AppendToEntryResponse {
        <AppendToEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl AppendToEntryResponse {
    pub fn new() -> AppendToEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AppendToEntryResponse>(
            "AppendToEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AppendToEntryResponse {
    const NAME: &'static str = "AppendToEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AppendToEntryResponse {
        AppendToEntryResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AppendToEntryResponse {
        static instance: AppendToEntryResponse = AppendToEntryResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AppendToEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AppendToEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AppendToEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AppendToEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.DeleteEntryRequest)
pub struct DeleteEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.is_delete_data)
    pub is_delete_data: bool,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.is_recursive)
    pub is_recursive: bool,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.ignore_recursive_error)
    pub ignore_recursive_error: bool,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.is_from_other_cluster)
    pub is_from_other_cluster: bool,
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryRequest.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.DeleteEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteEntryRequest {
    fn default() -> &'a DeleteEntryRequest {
        <DeleteEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteEntryRequest {
    pub fn new() -> DeleteEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &DeleteEntryRequest| { &m.directory },
            |m: &mut DeleteEntryRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeleteEntryRequest| { &m.name },
            |m: &mut DeleteEntryRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_delete_data",
            |m: &DeleteEntryRequest| { &m.is_delete_data },
            |m: &mut DeleteEntryRequest| { &mut m.is_delete_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_recursive",
            |m: &DeleteEntryRequest| { &m.is_recursive },
            |m: &mut DeleteEntryRequest| { &mut m.is_recursive },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ignore_recursive_error",
            |m: &DeleteEntryRequest| { &m.ignore_recursive_error },
            |m: &mut DeleteEntryRequest| { &mut m.ignore_recursive_error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_from_other_cluster",
            |m: &DeleteEntryRequest| { &m.is_from_other_cluster },
            |m: &mut DeleteEntryRequest| { &mut m.is_from_other_cluster },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &DeleteEntryRequest| { &m.signatures },
            |m: &mut DeleteEntryRequest| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteEntryRequest>(
            "DeleteEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteEntryRequest {
    const NAME: &'static str = "DeleteEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                32 => {
                    self.is_delete_data = is.read_bool()?;
                },
                40 => {
                    self.is_recursive = is.read_bool()?;
                },
                48 => {
                    self.ignore_recursive_error = is.read_bool()?;
                },
                56 => {
                    self.is_from_other_cluster = is.read_bool()?;
                },
                66 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                64 => {
                    self.signatures.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.is_delete_data != false {
            my_size += 1 + 1;
        }
        if self.is_recursive != false {
            my_size += 1 + 1;
        }
        if self.ignore_recursive_error != false {
            my_size += 1 + 1;
        }
        if self.is_from_other_cluster != false {
            my_size += 1 + 1;
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(8, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.is_delete_data != false {
            os.write_bool(4, self.is_delete_data)?;
        }
        if self.is_recursive != false {
            os.write_bool(5, self.is_recursive)?;
        }
        if self.ignore_recursive_error != false {
            os.write_bool(6, self.ignore_recursive_error)?;
        }
        if self.is_from_other_cluster != false {
            os.write_bool(7, self.is_from_other_cluster)?;
        }
        for v in &self.signatures {
            os.write_int32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteEntryRequest {
        DeleteEntryRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.name.clear();
        self.is_delete_data = false;
        self.is_recursive = false;
        self.ignore_recursive_error = false;
        self.is_from_other_cluster = false;
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteEntryRequest {
        static instance: DeleteEntryRequest = DeleteEntryRequest {
            directory: ::std::string::String::new(),
            name: ::std::string::String::new(),
            is_delete_data: false,
            is_recursive: false,
            ignore_recursive_error: false,
            is_from_other_cluster: false,
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.DeleteEntryResponse)
pub struct DeleteEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.DeleteEntryResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.DeleteEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteEntryResponse {
    fn default() -> &'a DeleteEntryResponse {
        <DeleteEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteEntryResponse {
    pub fn new() -> DeleteEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &DeleteEntryResponse| { &m.error },
            |m: &mut DeleteEntryResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteEntryResponse>(
            "DeleteEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteEntryResponse {
    const NAME: &'static str = "DeleteEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteEntryResponse {
        DeleteEntryResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteEntryResponse {
        static instance: DeleteEntryResponse = DeleteEntryResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AtomicRenameEntryRequest)
pub struct AtomicRenameEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.AtomicRenameEntryRequest.old_directory)
    pub old_directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AtomicRenameEntryRequest.old_name)
    pub old_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AtomicRenameEntryRequest.new_directory)
    pub new_directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AtomicRenameEntryRequest.new_name)
    pub new_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AtomicRenameEntryRequest.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AtomicRenameEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AtomicRenameEntryRequest {
    fn default() -> &'a AtomicRenameEntryRequest {
        <AtomicRenameEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl AtomicRenameEntryRequest {
    pub fn new() -> AtomicRenameEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_directory",
            |m: &AtomicRenameEntryRequest| { &m.old_directory },
            |m: &mut AtomicRenameEntryRequest| { &mut m.old_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_name",
            |m: &AtomicRenameEntryRequest| { &m.old_name },
            |m: &mut AtomicRenameEntryRequest| { &mut m.old_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_directory",
            |m: &AtomicRenameEntryRequest| { &m.new_directory },
            |m: &mut AtomicRenameEntryRequest| { &mut m.new_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_name",
            |m: &AtomicRenameEntryRequest| { &m.new_name },
            |m: &mut AtomicRenameEntryRequest| { &mut m.new_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &AtomicRenameEntryRequest| { &m.signatures },
            |m: &mut AtomicRenameEntryRequest| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AtomicRenameEntryRequest>(
            "AtomicRenameEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AtomicRenameEntryRequest {
    const NAME: &'static str = "AtomicRenameEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.old_directory = is.read_string()?;
                },
                18 => {
                    self.old_name = is.read_string()?;
                },
                26 => {
                    self.new_directory = is.read_string()?;
                },
                34 => {
                    self.new_name = is.read_string()?;
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                40 => {
                    self.signatures.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.old_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.old_directory);
        }
        if !self.old_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.old_name);
        }
        if !self.new_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.new_directory);
        }
        if !self.new_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.new_name);
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.old_directory.is_empty() {
            os.write_string(1, &self.old_directory)?;
        }
        if !self.old_name.is_empty() {
            os.write_string(2, &self.old_name)?;
        }
        if !self.new_directory.is_empty() {
            os.write_string(3, &self.new_directory)?;
        }
        if !self.new_name.is_empty() {
            os.write_string(4, &self.new_name)?;
        }
        for v in &self.signatures {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AtomicRenameEntryRequest {
        AtomicRenameEntryRequest::new()
    }

    fn clear(&mut self) {
        self.old_directory.clear();
        self.old_name.clear();
        self.new_directory.clear();
        self.new_name.clear();
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AtomicRenameEntryRequest {
        static instance: AtomicRenameEntryRequest = AtomicRenameEntryRequest {
            old_directory: ::std::string::String::new(),
            old_name: ::std::string::String::new(),
            new_directory: ::std::string::String::new(),
            new_name: ::std::string::String::new(),
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AtomicRenameEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AtomicRenameEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AtomicRenameEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AtomicRenameEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AtomicRenameEntryResponse)
pub struct AtomicRenameEntryResponse {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AtomicRenameEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AtomicRenameEntryResponse {
    fn default() -> &'a AtomicRenameEntryResponse {
        <AtomicRenameEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl AtomicRenameEntryResponse {
    pub fn new() -> AtomicRenameEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AtomicRenameEntryResponse>(
            "AtomicRenameEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AtomicRenameEntryResponse {
    const NAME: &'static str = "AtomicRenameEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AtomicRenameEntryResponse {
        AtomicRenameEntryResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AtomicRenameEntryResponse {
        static instance: AtomicRenameEntryResponse = AtomicRenameEntryResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AtomicRenameEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AtomicRenameEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AtomicRenameEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AtomicRenameEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.StreamRenameEntryRequest)
pub struct StreamRenameEntryRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryRequest.old_directory)
    pub old_directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryRequest.old_name)
    pub old_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryRequest.new_directory)
    pub new_directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryRequest.new_name)
    pub new_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryRequest.signatures)
    pub signatures: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.StreamRenameEntryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamRenameEntryRequest {
    fn default() -> &'a StreamRenameEntryRequest {
        <StreamRenameEntryRequest as ::protobuf::Message>::default_instance()
    }
}

impl StreamRenameEntryRequest {
    pub fn new() -> StreamRenameEntryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_directory",
            |m: &StreamRenameEntryRequest| { &m.old_directory },
            |m: &mut StreamRenameEntryRequest| { &mut m.old_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "old_name",
            |m: &StreamRenameEntryRequest| { &m.old_name },
            |m: &mut StreamRenameEntryRequest| { &mut m.old_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_directory",
            |m: &StreamRenameEntryRequest| { &m.new_directory },
            |m: &mut StreamRenameEntryRequest| { &mut m.new_directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "new_name",
            |m: &StreamRenameEntryRequest| { &m.new_name },
            |m: &mut StreamRenameEntryRequest| { &mut m.new_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "signatures",
            |m: &StreamRenameEntryRequest| { &m.signatures },
            |m: &mut StreamRenameEntryRequest| { &mut m.signatures },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamRenameEntryRequest>(
            "StreamRenameEntryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamRenameEntryRequest {
    const NAME: &'static str = "StreamRenameEntryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.old_directory = is.read_string()?;
                },
                18 => {
                    self.old_name = is.read_string()?;
                },
                26 => {
                    self.new_directory = is.read_string()?;
                },
                34 => {
                    self.new_name = is.read_string()?;
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.signatures)?;
                },
                40 => {
                    self.signatures.push(is.read_int32()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.old_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.old_directory);
        }
        if !self.old_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.old_name);
        }
        if !self.new_directory.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.new_directory);
        }
        if !self.new_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.new_name);
        }
        for value in &self.signatures {
            my_size += ::protobuf::rt::int32_size(5, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.old_directory.is_empty() {
            os.write_string(1, &self.old_directory)?;
        }
        if !self.old_name.is_empty() {
            os.write_string(2, &self.old_name)?;
        }
        if !self.new_directory.is_empty() {
            os.write_string(3, &self.new_directory)?;
        }
        if !self.new_name.is_empty() {
            os.write_string(4, &self.new_name)?;
        }
        for v in &self.signatures {
            os.write_int32(5, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamRenameEntryRequest {
        StreamRenameEntryRequest::new()
    }

    fn clear(&mut self) {
        self.old_directory.clear();
        self.old_name.clear();
        self.new_directory.clear();
        self.new_name.clear();
        self.signatures.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamRenameEntryRequest {
        static instance: StreamRenameEntryRequest = StreamRenameEntryRequest {
            old_directory: ::std::string::String::new(),
            old_name: ::std::string::String::new(),
            new_directory: ::std::string::String::new(),
            new_name: ::std::string::String::new(),
            signatures: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamRenameEntryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamRenameEntryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamRenameEntryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamRenameEntryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.StreamRenameEntryResponse)
pub struct StreamRenameEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryResponse.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryResponse.event_notification)
    pub event_notification: ::protobuf::MessageField<EventNotification>,
    // @@protoc_insertion_point(field:filer_pb.StreamRenameEntryResponse.ts_ns)
    pub ts_ns: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.StreamRenameEntryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StreamRenameEntryResponse {
    fn default() -> &'a StreamRenameEntryResponse {
        <StreamRenameEntryResponse as ::protobuf::Message>::default_instance()
    }
}

impl StreamRenameEntryResponse {
    pub fn new() -> StreamRenameEntryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &StreamRenameEntryResponse| { &m.directory },
            |m: &mut StreamRenameEntryResponse| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventNotification>(
            "event_notification",
            |m: &StreamRenameEntryResponse| { &m.event_notification },
            |m: &mut StreamRenameEntryResponse| { &mut m.event_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ts_ns",
            |m: &StreamRenameEntryResponse| { &m.ts_ns },
            |m: &mut StreamRenameEntryResponse| { &mut m.ts_ns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StreamRenameEntryResponse>(
            "StreamRenameEntryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StreamRenameEntryResponse {
    const NAME: &'static str = "StreamRenameEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event_notification)?;
                },
                24 => {
                    self.ts_ns = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if let Some(v) = self.event_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.ts_ns != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.ts_ns);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if let Some(v) = self.event_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.ts_ns != 0 {
            os.write_int64(3, self.ts_ns)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StreamRenameEntryResponse {
        StreamRenameEntryResponse::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.event_notification.clear();
        self.ts_ns = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StreamRenameEntryResponse {
        static instance: StreamRenameEntryResponse = StreamRenameEntryResponse {
            directory: ::std::string::String::new(),
            event_notification: ::protobuf::MessageField::none(),
            ts_ns: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StreamRenameEntryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StreamRenameEntryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StreamRenameEntryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StreamRenameEntryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AssignVolumeRequest)
pub struct AssignVolumeRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.count)
    pub count: i32,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.collection)
    pub collection: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.replication)
    pub replication: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.ttl_sec)
    pub ttl_sec: i32,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.data_center)
    pub data_center: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.path)
    pub path: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.rack)
    pub rack: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.data_node)
    pub data_node: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeRequest.disk_type)
    pub disk_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AssignVolumeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignVolumeRequest {
    fn default() -> &'a AssignVolumeRequest {
        <AssignVolumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl AssignVolumeRequest {
    pub fn new() -> AssignVolumeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &AssignVolumeRequest| { &m.count },
            |m: &mut AssignVolumeRequest| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collection",
            |m: &AssignVolumeRequest| { &m.collection },
            |m: &mut AssignVolumeRequest| { &mut m.collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replication",
            |m: &AssignVolumeRequest| { &m.replication },
            |m: &mut AssignVolumeRequest| { &mut m.replication },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ttl_sec",
            |m: &AssignVolumeRequest| { &m.ttl_sec },
            |m: &mut AssignVolumeRequest| { &mut m.ttl_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_center",
            |m: &AssignVolumeRequest| { &m.data_center },
            |m: &mut AssignVolumeRequest| { &mut m.data_center },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path",
            |m: &AssignVolumeRequest| { &m.path },
            |m: &mut AssignVolumeRequest| { &mut m.path },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rack",
            |m: &AssignVolumeRequest| { &m.rack },
            |m: &mut AssignVolumeRequest| { &mut m.rack },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data_node",
            |m: &AssignVolumeRequest| { &m.data_node },
            |m: &mut AssignVolumeRequest| { &mut m.data_node },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disk_type",
            |m: &AssignVolumeRequest| { &m.disk_type },
            |m: &mut AssignVolumeRequest| { &mut m.disk_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignVolumeRequest>(
            "AssignVolumeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignVolumeRequest {
    const NAME: &'static str = "AssignVolumeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = is.read_int32()?;
                },
                18 => {
                    self.collection = is.read_string()?;
                },
                26 => {
                    self.replication = is.read_string()?;
                },
                32 => {
                    self.ttl_sec = is.read_int32()?;
                },
                42 => {
                    self.data_center = is.read_string()?;
                },
                50 => {
                    self.path = is.read_string()?;
                },
                58 => {
                    self.rack = is.read_string()?;
                },
                74 => {
                    self.data_node = is.read_string()?;
                },
                66 => {
                    self.disk_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.count);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection);
        }
        if !self.replication.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.replication);
        }
        if self.ttl_sec != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.ttl_sec);
        }
        if !self.data_center.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.data_center);
        }
        if !self.path.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.path);
        }
        if !self.rack.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.rack);
        }
        if !self.data_node.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.data_node);
        }
        if !self.disk_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.disk_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.count != 0 {
            os.write_int32(1, self.count)?;
        }
        if !self.collection.is_empty() {
            os.write_string(2, &self.collection)?;
        }
        if !self.replication.is_empty() {
            os.write_string(3, &self.replication)?;
        }
        if self.ttl_sec != 0 {
            os.write_int32(4, self.ttl_sec)?;
        }
        if !self.data_center.is_empty() {
            os.write_string(5, &self.data_center)?;
        }
        if !self.path.is_empty() {
            os.write_string(6, &self.path)?;
        }
        if !self.rack.is_empty() {
            os.write_string(7, &self.rack)?;
        }
        if !self.data_node.is_empty() {
            os.write_string(9, &self.data_node)?;
        }
        if !self.disk_type.is_empty() {
            os.write_string(8, &self.disk_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignVolumeRequest {
        AssignVolumeRequest::new()
    }

    fn clear(&mut self) {
        self.count = 0;
        self.collection.clear();
        self.replication.clear();
        self.ttl_sec = 0;
        self.data_center.clear();
        self.path.clear();
        self.rack.clear();
        self.data_node.clear();
        self.disk_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignVolumeRequest {
        static instance: AssignVolumeRequest = AssignVolumeRequest {
            count: 0,
            collection: ::std::string::String::new(),
            replication: ::std::string::String::new(),
            ttl_sec: 0,
            data_center: ::std::string::String::new(),
            path: ::std::string::String::new(),
            rack: ::std::string::String::new(),
            data_node: ::std::string::String::new(),
            disk_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignVolumeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignVolumeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignVolumeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignVolumeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.AssignVolumeResponse)
pub struct AssignVolumeResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.file_id)
    pub file_id: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.count)
    pub count: i32,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.auth)
    pub auth: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.collection)
    pub collection: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.replication)
    pub replication: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.error)
    pub error: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.AssignVolumeResponse.location)
    pub location: ::protobuf::MessageField<Location>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.AssignVolumeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AssignVolumeResponse {
    fn default() -> &'a AssignVolumeResponse {
        <AssignVolumeResponse as ::protobuf::Message>::default_instance()
    }
}

impl AssignVolumeResponse {
    pub fn new() -> AssignVolumeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_id",
            |m: &AssignVolumeResponse| { &m.file_id },
            |m: &mut AssignVolumeResponse| { &mut m.file_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "count",
            |m: &AssignVolumeResponse| { &m.count },
            |m: &mut AssignVolumeResponse| { &mut m.count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auth",
            |m: &AssignVolumeResponse| { &m.auth },
            |m: &mut AssignVolumeResponse| { &mut m.auth },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collection",
            |m: &AssignVolumeResponse| { &m.collection },
            |m: &mut AssignVolumeResponse| { &mut m.collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replication",
            |m: &AssignVolumeResponse| { &m.replication },
            |m: &mut AssignVolumeResponse| { &mut m.replication },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &AssignVolumeResponse| { &m.error },
            |m: &mut AssignVolumeResponse| { &mut m.error },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Location>(
            "location",
            |m: &AssignVolumeResponse| { &m.location },
            |m: &mut AssignVolumeResponse| { &mut m.location },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AssignVolumeResponse>(
            "AssignVolumeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AssignVolumeResponse {
    const NAME: &'static str = "AssignVolumeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_id = is.read_string()?;
                },
                32 => {
                    self.count = is.read_int32()?;
                },
                42 => {
                    self.auth = is.read_string()?;
                },
                50 => {
                    self.collection = is.read_string()?;
                },
                58 => {
                    self.replication = is.read_string()?;
                },
                66 => {
                    self.error = is.read_string()?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.file_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file_id);
        }
        if self.count != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.count);
        }
        if !self.auth.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.auth);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.collection);
        }
        if !self.replication.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.replication);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.error);
        }
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.file_id.is_empty() {
            os.write_string(1, &self.file_id)?;
        }
        if self.count != 0 {
            os.write_int32(4, self.count)?;
        }
        if !self.auth.is_empty() {
            os.write_string(5, &self.auth)?;
        }
        if !self.collection.is_empty() {
            os.write_string(6, &self.collection)?;
        }
        if !self.replication.is_empty() {
            os.write_string(7, &self.replication)?;
        }
        if !self.error.is_empty() {
            os.write_string(8, &self.error)?;
        }
        if let Some(v) = self.location.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AssignVolumeResponse {
        AssignVolumeResponse::new()
    }

    fn clear(&mut self) {
        self.file_id.clear();
        self.count = 0;
        self.auth.clear();
        self.collection.clear();
        self.replication.clear();
        self.error.clear();
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AssignVolumeResponse {
        static instance: AssignVolumeResponse = AssignVolumeResponse {
            file_id: ::std::string::String::new(),
            count: 0,
            auth: ::std::string::String::new(),
            collection: ::std::string::String::new(),
            replication: ::std::string::String::new(),
            error: ::std::string::String::new(),
            location: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AssignVolumeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AssignVolumeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AssignVolumeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AssignVolumeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LookupVolumeRequest)
pub struct LookupVolumeRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LookupVolumeRequest.volume_ids)
    pub volume_ids: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LookupVolumeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LookupVolumeRequest {
    fn default() -> &'a LookupVolumeRequest {
        <LookupVolumeRequest as ::protobuf::Message>::default_instance()
    }
}

impl LookupVolumeRequest {
    pub fn new() -> LookupVolumeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volume_ids",
            |m: &LookupVolumeRequest| { &m.volume_ids },
            |m: &mut LookupVolumeRequest| { &mut m.volume_ids },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LookupVolumeRequest>(
            "LookupVolumeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LookupVolumeRequest {
    const NAME: &'static str = "LookupVolumeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.volume_ids.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.volume_ids {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.volume_ids {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LookupVolumeRequest {
        LookupVolumeRequest::new()
    }

    fn clear(&mut self) {
        self.volume_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LookupVolumeRequest {
        static instance: LookupVolumeRequest = LookupVolumeRequest {
            volume_ids: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LookupVolumeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LookupVolumeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LookupVolumeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LookupVolumeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.Locations)
pub struct Locations {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.Locations.locations)
    pub locations: ::std::vec::Vec<Location>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.Locations.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Locations {
    fn default() -> &'a Locations {
        <Locations as ::protobuf::Message>::default_instance()
    }
}

impl Locations {
    pub fn new() -> Locations {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locations",
            |m: &Locations| { &m.locations },
            |m: &mut Locations| { &mut m.locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Locations>(
            "Locations",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Locations {
    const NAME: &'static str = "Locations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.locations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.locations {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Locations {
        Locations::new()
    }

    fn clear(&mut self) {
        self.locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Locations {
        static instance: Locations = Locations {
            locations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Locations {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Locations").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Locations {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Locations {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.Location)
pub struct Location {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.Location.url)
    pub url: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.Location.public_url)
    pub public_url: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.Location.grpc_port)
    pub grpc_port: u32,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.Location.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "url",
            |m: &Location| { &m.url },
            |m: &mut Location| { &mut m.url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "public_url",
            |m: &Location| { &m.public_url },
            |m: &mut Location| { &mut m.public_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_port",
            |m: &Location| { &m.grpc_port },
            |m: &mut Location| { &mut m.grpc_port },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
            "Location",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Location {
    const NAME: &'static str = "Location";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.url = is.read_string()?;
                },
                18 => {
                    self.public_url = is.read_string()?;
                },
                24 => {
                    self.grpc_port = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.url.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.url);
        }
        if !self.public_url.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.public_url);
        }
        if self.grpc_port != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.grpc_port);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.url.is_empty() {
            os.write_string(1, &self.url)?;
        }
        if !self.public_url.is_empty() {
            os.write_string(2, &self.public_url)?;
        }
        if self.grpc_port != 0 {
            os.write_uint32(3, self.grpc_port)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Location {
        Location::new()
    }

    fn clear(&mut self) {
        self.url.clear();
        self.public_url.clear();
        self.grpc_port = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Location {
        static instance: Location = Location {
            url: ::std::string::String::new(),
            public_url: ::std::string::String::new(),
            grpc_port: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Location {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Location").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LookupVolumeResponse)
pub struct LookupVolumeResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LookupVolumeResponse.locations_map)
    pub locations_map: ::std::collections::HashMap<::std::string::String, Locations>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LookupVolumeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LookupVolumeResponse {
    fn default() -> &'a LookupVolumeResponse {
        <LookupVolumeResponse as ::protobuf::Message>::default_instance()
    }
}

impl LookupVolumeResponse {
    pub fn new() -> LookupVolumeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor::<_, _, _>(
            "locations_map",
            |m: &LookupVolumeResponse| { &m.locations_map },
            |m: &mut LookupVolumeResponse| { &mut m.locations_map },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LookupVolumeResponse>(
            "LookupVolumeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LookupVolumeResponse {
    const NAME: &'static str = "LookupVolumeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            10 => key = is.read_string()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.locations_map.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for (k, v) in &self.locations_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for (k, v) in &self.locations_map {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::string_size(1, &k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(10)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_string(1, &k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LookupVolumeResponse {
        LookupVolumeResponse::new()
    }

    fn clear(&mut self) {
        self.locations_map.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LookupVolumeResponse {
        static instance: ::protobuf::rt::Lazy<LookupVolumeResponse> = ::protobuf::rt::Lazy::new();
        instance.get(LookupVolumeResponse::new)
    }
}

impl ::protobuf::MessageFull for LookupVolumeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LookupVolumeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LookupVolumeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LookupVolumeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.Collection)
pub struct Collection {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.Collection.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.Collection.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Collection {
    fn default() -> &'a Collection {
        <Collection as ::protobuf::Message>::default_instance()
    }
}

impl Collection {
    pub fn new() -> Collection {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Collection| { &m.name },
            |m: &mut Collection| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Collection>(
            "Collection",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Collection {
    const NAME: &'static str = "Collection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Collection {
        Collection::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Collection {
        static instance: Collection = Collection {
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Collection {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Collection").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Collection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Collection {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CollectionListRequest)
pub struct CollectionListRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CollectionListRequest.include_normal_volumes)
    pub include_normal_volumes: bool,
    // @@protoc_insertion_point(field:filer_pb.CollectionListRequest.include_ec_volumes)
    pub include_ec_volumes: bool,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CollectionListRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectionListRequest {
    fn default() -> &'a CollectionListRequest {
        <CollectionListRequest as ::protobuf::Message>::default_instance()
    }
}

impl CollectionListRequest {
    pub fn new() -> CollectionListRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_normal_volumes",
            |m: &CollectionListRequest| { &m.include_normal_volumes },
            |m: &mut CollectionListRequest| { &mut m.include_normal_volumes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_ec_volumes",
            |m: &CollectionListRequest| { &m.include_ec_volumes },
            |m: &mut CollectionListRequest| { &mut m.include_ec_volumes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionListRequest>(
            "CollectionListRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectionListRequest {
    const NAME: &'static str = "CollectionListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.include_normal_volumes = is.read_bool()?;
                },
                16 => {
                    self.include_ec_volumes = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.include_normal_volumes != false {
            my_size += 1 + 1;
        }
        if self.include_ec_volumes != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.include_normal_volumes != false {
            os.write_bool(1, self.include_normal_volumes)?;
        }
        if self.include_ec_volumes != false {
            os.write_bool(2, self.include_ec_volumes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectionListRequest {
        CollectionListRequest::new()
    }

    fn clear(&mut self) {
        self.include_normal_volumes = false;
        self.include_ec_volumes = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectionListRequest {
        static instance: CollectionListRequest = CollectionListRequest {
            include_normal_volumes: false,
            include_ec_volumes: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectionListRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectionListRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectionListRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionListRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CollectionListResponse)
pub struct CollectionListResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CollectionListResponse.collections)
    pub collections: ::std::vec::Vec<Collection>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CollectionListResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CollectionListResponse {
    fn default() -> &'a CollectionListResponse {
        <CollectionListResponse as ::protobuf::Message>::default_instance()
    }
}

impl CollectionListResponse {
    pub fn new() -> CollectionListResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "collections",
            |m: &CollectionListResponse| { &m.collections },
            |m: &mut CollectionListResponse| { &mut m.collections },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CollectionListResponse>(
            "CollectionListResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CollectionListResponse {
    const NAME: &'static str = "CollectionListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.collections.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.collections {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.collections {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CollectionListResponse {
        CollectionListResponse::new()
    }

    fn clear(&mut self) {
        self.collections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CollectionListResponse {
        static instance: CollectionListResponse = CollectionListResponse {
            collections: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CollectionListResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CollectionListResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CollectionListResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CollectionListResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.DeleteCollectionRequest)
pub struct DeleteCollectionRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.DeleteCollectionRequest.collection)
    pub collection: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.DeleteCollectionRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollectionRequest {
    fn default() -> &'a DeleteCollectionRequest {
        <DeleteCollectionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectionRequest {
    pub fn new() -> DeleteCollectionRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collection",
            |m: &DeleteCollectionRequest| { &m.collection },
            |m: &mut DeleteCollectionRequest| { &mut m.collection },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollectionRequest>(
            "DeleteCollectionRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollectionRequest {
    const NAME: &'static str = "DeleteCollectionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.collection = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.collection);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.collection.is_empty() {
            os.write_string(1, &self.collection)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollectionRequest {
        DeleteCollectionRequest::new()
    }

    fn clear(&mut self) {
        self.collection.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollectionRequest {
        static instance: DeleteCollectionRequest = DeleteCollectionRequest {
            collection: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollectionRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollectionRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollectionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectionRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.DeleteCollectionResponse)
pub struct DeleteCollectionResponse {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.DeleteCollectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeleteCollectionResponse {
    fn default() -> &'a DeleteCollectionResponse {
        <DeleteCollectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteCollectionResponse {
    pub fn new() -> DeleteCollectionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeleteCollectionResponse>(
            "DeleteCollectionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeleteCollectionResponse {
    const NAME: &'static str = "DeleteCollectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeleteCollectionResponse {
        DeleteCollectionResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeleteCollectionResponse {
        static instance: DeleteCollectionResponse = DeleteCollectionResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeleteCollectionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeleteCollectionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeleteCollectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteCollectionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.StatisticsRequest)
pub struct StatisticsRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.StatisticsRequest.replication)
    pub replication: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StatisticsRequest.collection)
    pub collection: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StatisticsRequest.ttl)
    pub ttl: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.StatisticsRequest.disk_type)
    pub disk_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.StatisticsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatisticsRequest {
    fn default() -> &'a StatisticsRequest {
        <StatisticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl StatisticsRequest {
    pub fn new() -> StatisticsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replication",
            |m: &StatisticsRequest| { &m.replication },
            |m: &mut StatisticsRequest| { &mut m.replication },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collection",
            |m: &StatisticsRequest| { &m.collection },
            |m: &mut StatisticsRequest| { &mut m.collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ttl",
            |m: &StatisticsRequest| { &m.ttl },
            |m: &mut StatisticsRequest| { &mut m.ttl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disk_type",
            |m: &StatisticsRequest| { &m.disk_type },
            |m: &mut StatisticsRequest| { &mut m.disk_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatisticsRequest>(
            "StatisticsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatisticsRequest {
    const NAME: &'static str = "StatisticsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.replication = is.read_string()?;
                },
                18 => {
                    self.collection = is.read_string()?;
                },
                26 => {
                    self.ttl = is.read_string()?;
                },
                34 => {
                    self.disk_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.replication.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.replication);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.collection);
        }
        if !self.ttl.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ttl);
        }
        if !self.disk_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.disk_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.replication.is_empty() {
            os.write_string(1, &self.replication)?;
        }
        if !self.collection.is_empty() {
            os.write_string(2, &self.collection)?;
        }
        if !self.ttl.is_empty() {
            os.write_string(3, &self.ttl)?;
        }
        if !self.disk_type.is_empty() {
            os.write_string(4, &self.disk_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatisticsRequest {
        StatisticsRequest::new()
    }

    fn clear(&mut self) {
        self.replication.clear();
        self.collection.clear();
        self.ttl.clear();
        self.disk_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatisticsRequest {
        static instance: StatisticsRequest = StatisticsRequest {
            replication: ::std::string::String::new(),
            collection: ::std::string::String::new(),
            ttl: ::std::string::String::new(),
            disk_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatisticsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatisticsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatisticsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatisticsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.StatisticsResponse)
pub struct StatisticsResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.StatisticsResponse.total_size)
    pub total_size: u64,
    // @@protoc_insertion_point(field:filer_pb.StatisticsResponse.used_size)
    pub used_size: u64,
    // @@protoc_insertion_point(field:filer_pb.StatisticsResponse.file_count)
    pub file_count: u64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.StatisticsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a StatisticsResponse {
    fn default() -> &'a StatisticsResponse {
        <StatisticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatisticsResponse {
    pub fn new() -> StatisticsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_size",
            |m: &StatisticsResponse| { &m.total_size },
            |m: &mut StatisticsResponse| { &mut m.total_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "used_size",
            |m: &StatisticsResponse| { &m.used_size },
            |m: &mut StatisticsResponse| { &mut m.used_size },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "file_count",
            |m: &StatisticsResponse| { &m.file_count },
            |m: &mut StatisticsResponse| { &mut m.file_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StatisticsResponse>(
            "StatisticsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for StatisticsResponse {
    const NAME: &'static str = "StatisticsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.total_size = is.read_uint64()?;
                },
                40 => {
                    self.used_size = is.read_uint64()?;
                },
                48 => {
                    self.file_count = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.total_size != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.total_size);
        }
        if self.used_size != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.used_size);
        }
        if self.file_count != 0 {
            my_size += ::protobuf::rt::uint64_size(6, self.file_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.total_size != 0 {
            os.write_uint64(4, self.total_size)?;
        }
        if self.used_size != 0 {
            os.write_uint64(5, self.used_size)?;
        }
        if self.file_count != 0 {
            os.write_uint64(6, self.file_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> StatisticsResponse {
        StatisticsResponse::new()
    }

    fn clear(&mut self) {
        self.total_size = 0;
        self.used_size = 0;
        self.file_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static StatisticsResponse {
        static instance: StatisticsResponse = StatisticsResponse {
            total_size: 0,
            used_size: 0,
            file_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for StatisticsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("StatisticsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for StatisticsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatisticsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.PingRequest)
pub struct PingRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.PingRequest.target)
    pub target: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.PingRequest.target_type)
    pub target_type: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target",
            |m: &PingRequest| { &m.target },
            |m: &mut PingRequest| { &mut m.target },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_type",
            |m: &PingRequest| { &m.target_type },
            |m: &mut PingRequest| { &mut m.target_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target = is.read_string()?;
                },
                18 => {
                    self.target_type = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.target.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.target);
        }
        if !self.target_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.target_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.target.is_empty() {
            os.write_string(1, &self.target)?;
        }
        if !self.target_type.is_empty() {
            os.write_string(2, &self.target_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.target.clear();
        self.target_type.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            target: ::std::string::String::new(),
            target_type: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.PingResponse)
pub struct PingResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.PingResponse.start_time_ns)
    pub start_time_ns: i64,
    // @@protoc_insertion_point(field:filer_pb.PingResponse.remote_time_ns)
    pub remote_time_ns: i64,
    // @@protoc_insertion_point(field:filer_pb.PingResponse.stop_time_ns)
    pub stop_time_ns: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_time_ns",
            |m: &PingResponse| { &m.start_time_ns },
            |m: &mut PingResponse| { &mut m.start_time_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "remote_time_ns",
            |m: &PingResponse| { &m.remote_time_ns },
            |m: &mut PingResponse| { &mut m.remote_time_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stop_time_ns",
            |m: &PingResponse| { &m.stop_time_ns },
            |m: &mut PingResponse| { &mut m.stop_time_ns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_time_ns = is.read_int64()?;
                },
                16 => {
                    self.remote_time_ns = is.read_int64()?;
                },
                24 => {
                    self.stop_time_ns = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.start_time_ns != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.start_time_ns);
        }
        if self.remote_time_ns != 0 {
            my_size += ::protobuf::rt::int64_size(2, self.remote_time_ns);
        }
        if self.stop_time_ns != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.stop_time_ns);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.start_time_ns != 0 {
            os.write_int64(1, self.start_time_ns)?;
        }
        if self.remote_time_ns != 0 {
            os.write_int64(2, self.remote_time_ns)?;
        }
        if self.stop_time_ns != 0 {
            os.write_int64(3, self.stop_time_ns)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.start_time_ns = 0;
        self.remote_time_ns = 0;
        self.stop_time_ns = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            start_time_ns: 0,
            remote_time_ns: 0,
            stop_time_ns: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.GetFilerConfigurationRequest)
pub struct GetFilerConfigurationRequest {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.GetFilerConfigurationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFilerConfigurationRequest {
    fn default() -> &'a GetFilerConfigurationRequest {
        <GetFilerConfigurationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetFilerConfigurationRequest {
    pub fn new() -> GetFilerConfigurationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFilerConfigurationRequest>(
            "GetFilerConfigurationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFilerConfigurationRequest {
    const NAME: &'static str = "GetFilerConfigurationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFilerConfigurationRequest {
        GetFilerConfigurationRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFilerConfigurationRequest {
        static instance: GetFilerConfigurationRequest = GetFilerConfigurationRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFilerConfigurationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFilerConfigurationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFilerConfigurationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFilerConfigurationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.GetFilerConfigurationResponse)
pub struct GetFilerConfigurationResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.masters)
    pub masters: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.replication)
    pub replication: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.collection)
    pub collection: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.max_mb)
    pub max_mb: u32,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.dir_buckets)
    pub dir_buckets: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.cipher)
    pub cipher: bool,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.signature)
    pub signature: i32,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.metrics_address)
    pub metrics_address: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.metrics_interval_sec)
    pub metrics_interval_sec: i32,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.version)
    pub version: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.cluster_id)
    pub cluster_id: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.GetFilerConfigurationResponse.filer_group)
    pub filer_group: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.GetFilerConfigurationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetFilerConfigurationResponse {
    fn default() -> &'a GetFilerConfigurationResponse {
        <GetFilerConfigurationResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetFilerConfigurationResponse {
    pub fn new() -> GetFilerConfigurationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "masters",
            |m: &GetFilerConfigurationResponse| { &m.masters },
            |m: &mut GetFilerConfigurationResponse| { &mut m.masters },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "replication",
            |m: &GetFilerConfigurationResponse| { &m.replication },
            |m: &mut GetFilerConfigurationResponse| { &mut m.replication },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "collection",
            |m: &GetFilerConfigurationResponse| { &m.collection },
            |m: &mut GetFilerConfigurationResponse| { &mut m.collection },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_mb",
            |m: &GetFilerConfigurationResponse| { &m.max_mb },
            |m: &mut GetFilerConfigurationResponse| { &mut m.max_mb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dir_buckets",
            |m: &GetFilerConfigurationResponse| { &m.dir_buckets },
            |m: &mut GetFilerConfigurationResponse| { &mut m.dir_buckets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cipher",
            |m: &GetFilerConfigurationResponse| { &m.cipher },
            |m: &mut GetFilerConfigurationResponse| { &mut m.cipher },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &GetFilerConfigurationResponse| { &m.signature },
            |m: &mut GetFilerConfigurationResponse| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_address",
            |m: &GetFilerConfigurationResponse| { &m.metrics_address },
            |m: &mut GetFilerConfigurationResponse| { &mut m.metrics_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "metrics_interval_sec",
            |m: &GetFilerConfigurationResponse| { &m.metrics_interval_sec },
            |m: &mut GetFilerConfigurationResponse| { &mut m.metrics_interval_sec },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &GetFilerConfigurationResponse| { &m.version },
            |m: &mut GetFilerConfigurationResponse| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cluster_id",
            |m: &GetFilerConfigurationResponse| { &m.cluster_id },
            |m: &mut GetFilerConfigurationResponse| { &mut m.cluster_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "filer_group",
            |m: &GetFilerConfigurationResponse| { &m.filer_group },
            |m: &mut GetFilerConfigurationResponse| { &mut m.filer_group },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetFilerConfigurationResponse>(
            "GetFilerConfigurationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetFilerConfigurationResponse {
    const NAME: &'static str = "GetFilerConfigurationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.masters.push(is.read_string()?);
                },
                18 => {
                    self.replication = is.read_string()?;
                },
                26 => {
                    self.collection = is.read_string()?;
                },
                32 => {
                    self.max_mb = is.read_uint32()?;
                },
                42 => {
                    self.dir_buckets = is.read_string()?;
                },
                56 => {
                    self.cipher = is.read_bool()?;
                },
                64 => {
                    self.signature = is.read_int32()?;
                },
                74 => {
                    self.metrics_address = is.read_string()?;
                },
                80 => {
                    self.metrics_interval_sec = is.read_int32()?;
                },
                90 => {
                    self.version = is.read_string()?;
                },
                98 => {
                    self.cluster_id = is.read_string()?;
                },
                106 => {
                    self.filer_group = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.masters {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.replication.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.replication);
        }
        if !self.collection.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.collection);
        }
        if self.max_mb != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.max_mb);
        }
        if !self.dir_buckets.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.dir_buckets);
        }
        if self.cipher != false {
            my_size += 1 + 1;
        }
        if self.signature != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.signature);
        }
        if !self.metrics_address.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.metrics_address);
        }
        if self.metrics_interval_sec != 0 {
            my_size += ::protobuf::rt::int32_size(10, self.metrics_interval_sec);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.version);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.cluster_id);
        }
        if !self.filer_group.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.filer_group);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.masters {
            os.write_string(1, &v)?;
        };
        if !self.replication.is_empty() {
            os.write_string(2, &self.replication)?;
        }
        if !self.collection.is_empty() {
            os.write_string(3, &self.collection)?;
        }
        if self.max_mb != 0 {
            os.write_uint32(4, self.max_mb)?;
        }
        if !self.dir_buckets.is_empty() {
            os.write_string(5, &self.dir_buckets)?;
        }
        if self.cipher != false {
            os.write_bool(7, self.cipher)?;
        }
        if self.signature != 0 {
            os.write_int32(8, self.signature)?;
        }
        if !self.metrics_address.is_empty() {
            os.write_string(9, &self.metrics_address)?;
        }
        if self.metrics_interval_sec != 0 {
            os.write_int32(10, self.metrics_interval_sec)?;
        }
        if !self.version.is_empty() {
            os.write_string(11, &self.version)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(12, &self.cluster_id)?;
        }
        if !self.filer_group.is_empty() {
            os.write_string(13, &self.filer_group)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetFilerConfigurationResponse {
        GetFilerConfigurationResponse::new()
    }

    fn clear(&mut self) {
        self.masters.clear();
        self.replication.clear();
        self.collection.clear();
        self.max_mb = 0;
        self.dir_buckets.clear();
        self.cipher = false;
        self.signature = 0;
        self.metrics_address.clear();
        self.metrics_interval_sec = 0;
        self.version.clear();
        self.cluster_id.clear();
        self.filer_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetFilerConfigurationResponse {
        static instance: GetFilerConfigurationResponse = GetFilerConfigurationResponse {
            masters: ::std::vec::Vec::new(),
            replication: ::std::string::String::new(),
            collection: ::std::string::String::new(),
            max_mb: 0,
            dir_buckets: ::std::string::String::new(),
            cipher: false,
            signature: 0,
            metrics_address: ::std::string::String::new(),
            metrics_interval_sec: 0,
            version: ::std::string::String::new(),
            cluster_id: ::std::string::String::new(),
            filer_group: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetFilerConfigurationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetFilerConfigurationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetFilerConfigurationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetFilerConfigurationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.SubscribeMetadataRequest)
pub struct SubscribeMetadataRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.client_name)
    pub client_name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.path_prefix)
    pub path_prefix: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.since_ns)
    pub since_ns: i64,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.signature)
    pub signature: i32,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.path_prefixes)
    pub path_prefixes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.client_id)
    pub client_id: i32,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataRequest.until_ns)
    pub until_ns: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.SubscribeMetadataRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeMetadataRequest {
    fn default() -> &'a SubscribeMetadataRequest {
        <SubscribeMetadataRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeMetadataRequest {
    pub fn new() -> SubscribeMetadataRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_name",
            |m: &SubscribeMetadataRequest| { &m.client_name },
            |m: &mut SubscribeMetadataRequest| { &mut m.client_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "path_prefix",
            |m: &SubscribeMetadataRequest| { &m.path_prefix },
            |m: &mut SubscribeMetadataRequest| { &mut m.path_prefix },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "since_ns",
            |m: &SubscribeMetadataRequest| { &m.since_ns },
            |m: &mut SubscribeMetadataRequest| { &mut m.since_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "signature",
            |m: &SubscribeMetadataRequest| { &m.signature },
            |m: &mut SubscribeMetadataRequest| { &mut m.signature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "path_prefixes",
            |m: &SubscribeMetadataRequest| { &m.path_prefixes },
            |m: &mut SubscribeMetadataRequest| { &mut m.path_prefixes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_id",
            |m: &SubscribeMetadataRequest| { &m.client_id },
            |m: &mut SubscribeMetadataRequest| { &mut m.client_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "until_ns",
            |m: &SubscribeMetadataRequest| { &m.until_ns },
            |m: &mut SubscribeMetadataRequest| { &mut m.until_ns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeMetadataRequest>(
            "SubscribeMetadataRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeMetadataRequest {
    const NAME: &'static str = "SubscribeMetadataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_name = is.read_string()?;
                },
                18 => {
                    self.path_prefix = is.read_string()?;
                },
                24 => {
                    self.since_ns = is.read_int64()?;
                },
                32 => {
                    self.signature = is.read_int32()?;
                },
                50 => {
                    self.path_prefixes.push(is.read_string()?);
                },
                56 => {
                    self.client_id = is.read_int32()?;
                },
                64 => {
                    self.until_ns = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_name);
        }
        if !self.path_prefix.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.path_prefix);
        }
        if self.since_ns != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.since_ns);
        }
        if self.signature != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.signature);
        }
        for value in &self.path_prefixes {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.client_id != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.client_id);
        }
        if self.until_ns != 0 {
            my_size += ::protobuf::rt::int64_size(8, self.until_ns);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_name.is_empty() {
            os.write_string(1, &self.client_name)?;
        }
        if !self.path_prefix.is_empty() {
            os.write_string(2, &self.path_prefix)?;
        }
        if self.since_ns != 0 {
            os.write_int64(3, self.since_ns)?;
        }
        if self.signature != 0 {
            os.write_int32(4, self.signature)?;
        }
        for v in &self.path_prefixes {
            os.write_string(6, &v)?;
        };
        if self.client_id != 0 {
            os.write_int32(7, self.client_id)?;
        }
        if self.until_ns != 0 {
            os.write_int64(8, self.until_ns)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeMetadataRequest {
        SubscribeMetadataRequest::new()
    }

    fn clear(&mut self) {
        self.client_name.clear();
        self.path_prefix.clear();
        self.since_ns = 0;
        self.signature = 0;
        self.path_prefixes.clear();
        self.client_id = 0;
        self.until_ns = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeMetadataRequest {
        static instance: SubscribeMetadataRequest = SubscribeMetadataRequest {
            client_name: ::std::string::String::new(),
            path_prefix: ::std::string::String::new(),
            since_ns: 0,
            signature: 0,
            path_prefixes: ::std::vec::Vec::new(),
            client_id: 0,
            until_ns: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeMetadataRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeMetadataRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeMetadataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeMetadataRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.SubscribeMetadataResponse)
pub struct SubscribeMetadataResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataResponse.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataResponse.event_notification)
    pub event_notification: ::protobuf::MessageField<EventNotification>,
    // @@protoc_insertion_point(field:filer_pb.SubscribeMetadataResponse.ts_ns)
    pub ts_ns: i64,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.SubscribeMetadataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeMetadataResponse {
    fn default() -> &'a SubscribeMetadataResponse {
        <SubscribeMetadataResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeMetadataResponse {
    pub fn new() -> SubscribeMetadataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &SubscribeMetadataResponse| { &m.directory },
            |m: &mut SubscribeMetadataResponse| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, EventNotification>(
            "event_notification",
            |m: &SubscribeMetadataResponse| { &m.event_notification },
            |m: &mut SubscribeMetadataResponse| { &mut m.event_notification },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ts_ns",
            |m: &SubscribeMetadataResponse| { &m.ts_ns },
            |m: &mut SubscribeMetadataResponse| { &mut m.ts_ns },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeMetadataResponse>(
            "SubscribeMetadataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeMetadataResponse {
    const NAME: &'static str = "SubscribeMetadataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.event_notification)?;
                },
                24 => {
                    self.ts_ns = is.read_int64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if let Some(v) = self.event_notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.ts_ns != 0 {
            my_size += ::protobuf::rt::int64_size(3, self.ts_ns);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if let Some(v) = self.event_notification.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.ts_ns != 0 {
            os.write_int64(3, self.ts_ns)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeMetadataResponse {
        SubscribeMetadataResponse::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.event_notification.clear();
        self.ts_ns = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeMetadataResponse {
        static instance: SubscribeMetadataResponse = SubscribeMetadataResponse {
            directory: ::std::string::String::new(),
            event_notification: ::protobuf::MessageField::none(),
            ts_ns: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeMetadataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeMetadataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeMetadataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeMetadataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LogEntry)
pub struct LogEntry {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LogEntry.ts_ns)
    pub ts_ns: i64,
    // @@protoc_insertion_point(field:filer_pb.LogEntry.partition_key_hash)
    pub partition_key_hash: i32,
    // @@protoc_insertion_point(field:filer_pb.LogEntry.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LogEntry.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LogEntry {
    fn default() -> &'a LogEntry {
        <LogEntry as ::protobuf::Message>::default_instance()
    }
}

impl LogEntry {
    pub fn new() -> LogEntry {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "ts_ns",
            |m: &LogEntry| { &m.ts_ns },
            |m: &mut LogEntry| { &mut m.ts_ns },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "partition_key_hash",
            |m: &LogEntry| { &m.partition_key_hash },
            |m: &mut LogEntry| { &mut m.partition_key_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &LogEntry| { &m.data },
            |m: &mut LogEntry| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LogEntry>(
            "LogEntry",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LogEntry {
    const NAME: &'static str = "LogEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ts_ns = is.read_int64()?;
                },
                16 => {
                    self.partition_key_hash = is.read_int32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.ts_ns != 0 {
            my_size += ::protobuf::rt::int64_size(1, self.ts_ns);
        }
        if self.partition_key_hash != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.partition_key_hash);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.ts_ns != 0 {
            os.write_int64(1, self.ts_ns)?;
        }
        if self.partition_key_hash != 0 {
            os.write_int32(2, self.partition_key_hash)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LogEntry {
        LogEntry::new()
    }

    fn clear(&mut self) {
        self.ts_ns = 0;
        self.partition_key_hash = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LogEntry {
        static instance: LogEntry = LogEntry {
            ts_ns: 0,
            partition_key_hash: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LogEntry {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LogEntry").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogEntry {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KeepConnectedRequest)
pub struct KeepConnectedRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.KeepConnectedRequest.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.KeepConnectedRequest.grpc_port)
    pub grpc_port: u32,
    // @@protoc_insertion_point(field:filer_pb.KeepConnectedRequest.resources)
    pub resources: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KeepConnectedRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeepConnectedRequest {
    fn default() -> &'a KeepConnectedRequest {
        <KeepConnectedRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeepConnectedRequest {
    pub fn new() -> KeepConnectedRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &KeepConnectedRequest| { &m.name },
            |m: &mut KeepConnectedRequest| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "grpc_port",
            |m: &KeepConnectedRequest| { &m.grpc_port },
            |m: &mut KeepConnectedRequest| { &mut m.grpc_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &KeepConnectedRequest| { &m.resources },
            |m: &mut KeepConnectedRequest| { &mut m.resources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeepConnectedRequest>(
            "KeepConnectedRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeepConnectedRequest {
    const NAME: &'static str = "KeepConnectedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.grpc_port = is.read_uint32()?;
                },
                26 => {
                    self.resources.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.grpc_port != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.grpc_port);
        }
        for value in &self.resources {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.grpc_port != 0 {
            os.write_uint32(2, self.grpc_port)?;
        }
        for v in &self.resources {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeepConnectedRequest {
        KeepConnectedRequest::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.grpc_port = 0;
        self.resources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeepConnectedRequest {
        static instance: KeepConnectedRequest = KeepConnectedRequest {
            name: ::std::string::String::new(),
            grpc_port: 0,
            resources: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeepConnectedRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeepConnectedRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeepConnectedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepConnectedRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KeepConnectedResponse)
pub struct KeepConnectedResponse {
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KeepConnectedResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KeepConnectedResponse {
    fn default() -> &'a KeepConnectedResponse {
        <KeepConnectedResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeepConnectedResponse {
    pub fn new() -> KeepConnectedResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KeepConnectedResponse>(
            "KeepConnectedResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KeepConnectedResponse {
    const NAME: &'static str = "KeepConnectedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KeepConnectedResponse {
        KeepConnectedResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KeepConnectedResponse {
        static instance: KeepConnectedResponse = KeepConnectedResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KeepConnectedResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KeepConnectedResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KeepConnectedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepConnectedResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LocateBrokerRequest)
pub struct LocateBrokerRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LocateBrokerRequest.resource)
    pub resource: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LocateBrokerRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocateBrokerRequest {
    fn default() -> &'a LocateBrokerRequest {
        <LocateBrokerRequest as ::protobuf::Message>::default_instance()
    }
}

impl LocateBrokerRequest {
    pub fn new() -> LocateBrokerRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "resource",
            |m: &LocateBrokerRequest| { &m.resource },
            |m: &mut LocateBrokerRequest| { &mut m.resource },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocateBrokerRequest>(
            "LocateBrokerRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocateBrokerRequest {
    const NAME: &'static str = "LocateBrokerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.resource = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.resource.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.resource);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.resource.is_empty() {
            os.write_string(1, &self.resource)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocateBrokerRequest {
        LocateBrokerRequest::new()
    }

    fn clear(&mut self) {
        self.resource.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocateBrokerRequest {
        static instance: LocateBrokerRequest = LocateBrokerRequest {
            resource: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocateBrokerRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocateBrokerRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocateBrokerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocateBrokerRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.LocateBrokerResponse)
pub struct LocateBrokerResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.LocateBrokerResponse.found)
    pub found: bool,
    // @@protoc_insertion_point(field:filer_pb.LocateBrokerResponse.resources)
    pub resources: ::std::vec::Vec<locate_broker_response::Resource>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.LocateBrokerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LocateBrokerResponse {
    fn default() -> &'a LocateBrokerResponse {
        <LocateBrokerResponse as ::protobuf::Message>::default_instance()
    }
}

impl LocateBrokerResponse {
    pub fn new() -> LocateBrokerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "found",
            |m: &LocateBrokerResponse| { &m.found },
            |m: &mut LocateBrokerResponse| { &mut m.found },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "resources",
            |m: &LocateBrokerResponse| { &m.resources },
            |m: &mut LocateBrokerResponse| { &mut m.resources },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LocateBrokerResponse>(
            "LocateBrokerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LocateBrokerResponse {
    const NAME: &'static str = "LocateBrokerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.found = is.read_bool()?;
                },
                18 => {
                    self.resources.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.found != false {
            my_size += 1 + 1;
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.found != false {
            os.write_bool(1, self.found)?;
        }
        for v in &self.resources {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LocateBrokerResponse {
        LocateBrokerResponse::new()
    }

    fn clear(&mut self) {
        self.found = false;
        self.resources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LocateBrokerResponse {
        static instance: LocateBrokerResponse = LocateBrokerResponse {
            found: false,
            resources: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LocateBrokerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LocateBrokerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LocateBrokerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocateBrokerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LocateBrokerResponse`
pub mod locate_broker_response {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:filer_pb.LocateBrokerResponse.Resource)
    pub struct Resource {
        // message fields
        // @@protoc_insertion_point(field:filer_pb.LocateBrokerResponse.Resource.grpc_addresses)
        pub grpc_addresses: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.LocateBrokerResponse.Resource.resource_count)
        pub resource_count: i32,
        // special fields
        // @@protoc_insertion_point(special_field:filer_pb.LocateBrokerResponse.Resource.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Resource {
        fn default() -> &'a Resource {
            <Resource as ::protobuf::Message>::default_instance()
        }
    }

    impl Resource {
        pub fn new() -> Resource {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "grpc_addresses",
                |m: &Resource| { &m.grpc_addresses },
                |m: &mut Resource| { &mut m.grpc_addresses },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "resource_count",
                |m: &Resource| { &m.resource_count },
                |m: &mut Resource| { &mut m.resource_count },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Resource>(
                "LocateBrokerResponse.Resource",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for Resource {
        const NAME: &'static str = "Resource";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.grpc_addresses = is.read_string()?;
                    },
                    16 => {
                        self.resource_count = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.grpc_addresses.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.grpc_addresses);
            }
            if self.resource_count != 0 {
                my_size += ::protobuf::rt::int32_size(2, self.resource_count);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.grpc_addresses.is_empty() {
                os.write_string(1, &self.grpc_addresses)?;
            }
            if self.resource_count != 0 {
                os.write_int32(2, self.resource_count)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Resource {
            Resource::new()
        }

        fn clear(&mut self) {
            self.grpc_addresses.clear();
            self.resource_count = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Resource {
            static instance: Resource = Resource {
                grpc_addresses: ::std::string::String::new(),
                resource_count: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for Resource {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LocateBrokerResponse.Resource").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Resource {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for Resource {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KvGetRequest)
pub struct KvGetRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.KvGetRequest.key)
    pub key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KvGetRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KvGetRequest {
    fn default() -> &'a KvGetRequest {
        <KvGetRequest as ::protobuf::Message>::default_instance()
    }
}

impl KvGetRequest {
    pub fn new() -> KvGetRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KvGetRequest| { &m.key },
            |m: &mut KvGetRequest| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KvGetRequest>(
            "KvGetRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KvGetRequest {
    const NAME: &'static str = "KvGetRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KvGetRequest {
        KvGetRequest::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KvGetRequest {
        static instance: KvGetRequest = KvGetRequest {
            key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KvGetRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KvGetRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KvGetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvGetRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KvGetResponse)
pub struct KvGetResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.KvGetResponse.value)
    pub value: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.KvGetResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KvGetResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KvGetResponse {
    fn default() -> &'a KvGetResponse {
        <KvGetResponse as ::protobuf::Message>::default_instance()
    }
}

impl KvGetResponse {
    pub fn new() -> KvGetResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KvGetResponse| { &m.value },
            |m: &mut KvGetResponse| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &KvGetResponse| { &m.error },
            |m: &mut KvGetResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KvGetResponse>(
            "KvGetResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KvGetResponse {
    const NAME: &'static str = "KvGetResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = is.read_bytes()?;
                },
                18 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.value);
        }
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.value.is_empty() {
            os.write_bytes(1, &self.value)?;
        }
        if !self.error.is_empty() {
            os.write_string(2, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KvGetResponse {
        KvGetResponse::new()
    }

    fn clear(&mut self) {
        self.value.clear();
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KvGetResponse {
        static instance: KvGetResponse = KvGetResponse {
            value: ::std::vec::Vec::new(),
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KvGetResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KvGetResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KvGetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvGetResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KvPutRequest)
pub struct KvPutRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.KvPutRequest.key)
    pub key: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:filer_pb.KvPutRequest.value)
    pub value: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KvPutRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KvPutRequest {
    fn default() -> &'a KvPutRequest {
        <KvPutRequest as ::protobuf::Message>::default_instance()
    }
}

impl KvPutRequest {
    pub fn new() -> KvPutRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &KvPutRequest| { &m.key },
            |m: &mut KvPutRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &KvPutRequest| { &m.value },
            |m: &mut KvPutRequest| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KvPutRequest>(
            "KvPutRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KvPutRequest {
    const NAME: &'static str = "KvPutRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                18 => {
                    self.value = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KvPutRequest {
        KvPutRequest::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KvPutRequest {
        static instance: KvPutRequest = KvPutRequest {
            key: ::std::vec::Vec::new(),
            value: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KvPutRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KvPutRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KvPutRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvPutRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.KvPutResponse)
pub struct KvPutResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.KvPutResponse.error)
    pub error: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.KvPutResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a KvPutResponse {
    fn default() -> &'a KvPutResponse {
        <KvPutResponse as ::protobuf::Message>::default_instance()
    }
}

impl KvPutResponse {
    pub fn new() -> KvPutResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &KvPutResponse| { &m.error },
            |m: &mut KvPutResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<KvPutResponse>(
            "KvPutResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for KvPutResponse {
    const NAME: &'static str = "KvPutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error.is_empty() {
            os.write_string(1, &self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> KvPutResponse {
        KvPutResponse::new()
    }

    fn clear(&mut self) {
        self.error.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static KvPutResponse {
        static instance: KvPutResponse = KvPutResponse {
            error: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for KvPutResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("KvPutResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for KvPutResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KvPutResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.FilerConf)
pub struct FilerConf {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.FilerConf.version)
    pub version: i32,
    // @@protoc_insertion_point(field:filer_pb.FilerConf.locations)
    pub locations: ::std::vec::Vec<filer_conf::PathConf>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.FilerConf.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FilerConf {
    fn default() -> &'a FilerConf {
        <FilerConf as ::protobuf::Message>::default_instance()
    }
}

impl FilerConf {
    pub fn new() -> FilerConf {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "version",
            |m: &FilerConf| { &m.version },
            |m: &mut FilerConf| { &mut m.version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "locations",
            |m: &FilerConf| { &m.locations },
            |m: &mut FilerConf| { &mut m.locations },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FilerConf>(
            "FilerConf",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FilerConf {
    const NAME: &'static str = "FilerConf";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = is.read_int32()?;
                },
                18 => {
                    self.locations.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.version);
        }
        for value in &self.locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.version != 0 {
            os.write_int32(1, self.version)?;
        }
        for v in &self.locations {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FilerConf {
        FilerConf::new()
    }

    fn clear(&mut self) {
        self.version = 0;
        self.locations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FilerConf {
        static instance: FilerConf = FilerConf {
            version: 0,
            locations: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FilerConf {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FilerConf").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FilerConf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FilerConf {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FilerConf`
pub mod filer_conf {
    #[derive(PartialEq,Clone,Default,Debug)]
    // @@protoc_insertion_point(message:filer_pb.FilerConf.PathConf)
    pub struct PathConf {
        // message fields
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.location_prefix)
        pub location_prefix: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.collection)
        pub collection: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.replication)
        pub replication: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.ttl)
        pub ttl: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.disk_type)
        pub disk_type: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.fsync)
        pub fsync: bool,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.volume_growth_count)
        pub volume_growth_count: u32,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.read_only)
        pub read_only: bool,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.data_center)
        pub data_center: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.rack)
        pub rack: ::std::string::String,
        // @@protoc_insertion_point(field:filer_pb.FilerConf.PathConf.data_node)
        pub data_node: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:filer_pb.FilerConf.PathConf.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PathConf {
        fn default() -> &'a PathConf {
            <PathConf as ::protobuf::Message>::default_instance()
        }
    }

    impl PathConf {
        pub fn new() -> PathConf {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(11);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "location_prefix",
                |m: &PathConf| { &m.location_prefix },
                |m: &mut PathConf| { &mut m.location_prefix },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "collection",
                |m: &PathConf| { &m.collection },
                |m: &mut PathConf| { &mut m.collection },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "replication",
                |m: &PathConf| { &m.replication },
                |m: &mut PathConf| { &mut m.replication },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "ttl",
                |m: &PathConf| { &m.ttl },
                |m: &mut PathConf| { &mut m.ttl },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "disk_type",
                |m: &PathConf| { &m.disk_type },
                |m: &mut PathConf| { &mut m.disk_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "fsync",
                |m: &PathConf| { &m.fsync },
                |m: &mut PathConf| { &mut m.fsync },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "volume_growth_count",
                |m: &PathConf| { &m.volume_growth_count },
                |m: &mut PathConf| { &mut m.volume_growth_count },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "read_only",
                |m: &PathConf| { &m.read_only },
                |m: &mut PathConf| { &mut m.read_only },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data_center",
                |m: &PathConf| { &m.data_center },
                |m: &mut PathConf| { &mut m.data_center },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "rack",
                |m: &PathConf| { &m.rack },
                |m: &mut PathConf| { &mut m.rack },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "data_node",
                |m: &PathConf| { &m.data_node },
                |m: &mut PathConf| { &mut m.data_node },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PathConf>(
                "FilerConf.PathConf",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for PathConf {
        const NAME: &'static str = "PathConf";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.location_prefix = is.read_string()?;
                    },
                    18 => {
                        self.collection = is.read_string()?;
                    },
                    26 => {
                        self.replication = is.read_string()?;
                    },
                    34 => {
                        self.ttl = is.read_string()?;
                    },
                    42 => {
                        self.disk_type = is.read_string()?;
                    },
                    48 => {
                        self.fsync = is.read_bool()?;
                    },
                    56 => {
                        self.volume_growth_count = is.read_uint32()?;
                    },
                    64 => {
                        self.read_only = is.read_bool()?;
                    },
                    74 => {
                        self.data_center = is.read_string()?;
                    },
                    82 => {
                        self.rack = is.read_string()?;
                    },
                    90 => {
                        self.data_node = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.location_prefix.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.location_prefix);
            }
            if !self.collection.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.collection);
            }
            if !self.replication.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.replication);
            }
            if !self.ttl.is_empty() {
                my_size += ::protobuf::rt::string_size(4, &self.ttl);
            }
            if !self.disk_type.is_empty() {
                my_size += ::protobuf::rt::string_size(5, &self.disk_type);
            }
            if self.fsync != false {
                my_size += 1 + 1;
            }
            if self.volume_growth_count != 0 {
                my_size += ::protobuf::rt::uint32_size(7, self.volume_growth_count);
            }
            if self.read_only != false {
                my_size += 1 + 1;
            }
            if !self.data_center.is_empty() {
                my_size += ::protobuf::rt::string_size(9, &self.data_center);
            }
            if !self.rack.is_empty() {
                my_size += ::protobuf::rt::string_size(10, &self.rack);
            }
            if !self.data_node.is_empty() {
                my_size += ::protobuf::rt::string_size(11, &self.data_node);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.location_prefix.is_empty() {
                os.write_string(1, &self.location_prefix)?;
            }
            if !self.collection.is_empty() {
                os.write_string(2, &self.collection)?;
            }
            if !self.replication.is_empty() {
                os.write_string(3, &self.replication)?;
            }
            if !self.ttl.is_empty() {
                os.write_string(4, &self.ttl)?;
            }
            if !self.disk_type.is_empty() {
                os.write_string(5, &self.disk_type)?;
            }
            if self.fsync != false {
                os.write_bool(6, self.fsync)?;
            }
            if self.volume_growth_count != 0 {
                os.write_uint32(7, self.volume_growth_count)?;
            }
            if self.read_only != false {
                os.write_bool(8, self.read_only)?;
            }
            if !self.data_center.is_empty() {
                os.write_string(9, &self.data_center)?;
            }
            if !self.rack.is_empty() {
                os.write_string(10, &self.rack)?;
            }
            if !self.data_node.is_empty() {
                os.write_string(11, &self.data_node)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PathConf {
            PathConf::new()
        }

        fn clear(&mut self) {
            self.location_prefix.clear();
            self.collection.clear();
            self.replication.clear();
            self.ttl.clear();
            self.disk_type.clear();
            self.fsync = false;
            self.volume_growth_count = 0;
            self.read_only = false;
            self.data_center.clear();
            self.rack.clear();
            self.data_node.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PathConf {
            static instance: PathConf = PathConf {
                location_prefix: ::std::string::String::new(),
                collection: ::std::string::String::new(),
                replication: ::std::string::String::new(),
                ttl: ::std::string::String::new(),
                disk_type: ::std::string::String::new(),
                fsync: false,
                volume_growth_count: 0,
                read_only: false,
                data_center: ::std::string::String::new(),
                rack: ::std::string::String::new(),
                data_node: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for PathConf {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("FilerConf.PathConf").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for PathConf {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for PathConf {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CacheRemoteObjectToLocalClusterRequest)
pub struct CacheRemoteObjectToLocalClusterRequest {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CacheRemoteObjectToLocalClusterRequest.directory)
    pub directory: ::std::string::String,
    // @@protoc_insertion_point(field:filer_pb.CacheRemoteObjectToLocalClusterRequest.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CacheRemoteObjectToLocalClusterRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheRemoteObjectToLocalClusterRequest {
    fn default() -> &'a CacheRemoteObjectToLocalClusterRequest {
        <CacheRemoteObjectToLocalClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl CacheRemoteObjectToLocalClusterRequest {
    pub fn new() -> CacheRemoteObjectToLocalClusterRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "directory",
            |m: &CacheRemoteObjectToLocalClusterRequest| { &m.directory },
            |m: &mut CacheRemoteObjectToLocalClusterRequest| { &mut m.directory },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CacheRemoteObjectToLocalClusterRequest| { &m.name },
            |m: &mut CacheRemoteObjectToLocalClusterRequest| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheRemoteObjectToLocalClusterRequest>(
            "CacheRemoteObjectToLocalClusterRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheRemoteObjectToLocalClusterRequest {
    const NAME: &'static str = "CacheRemoteObjectToLocalClusterRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.directory = is.read_string()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.directory.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.directory);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.directory.is_empty() {
            os.write_string(1, &self.directory)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheRemoteObjectToLocalClusterRequest {
        CacheRemoteObjectToLocalClusterRequest::new()
    }

    fn clear(&mut self) {
        self.directory.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheRemoteObjectToLocalClusterRequest {
        static instance: CacheRemoteObjectToLocalClusterRequest = CacheRemoteObjectToLocalClusterRequest {
            directory: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheRemoteObjectToLocalClusterRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheRemoteObjectToLocalClusterRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheRemoteObjectToLocalClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheRemoteObjectToLocalClusterRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(PartialEq,Clone,Default,Debug)]
// @@protoc_insertion_point(message:filer_pb.CacheRemoteObjectToLocalClusterResponse)
pub struct CacheRemoteObjectToLocalClusterResponse {
    // message fields
    // @@protoc_insertion_point(field:filer_pb.CacheRemoteObjectToLocalClusterResponse.entry)
    pub entry: ::protobuf::MessageField<Entry>,
    // special fields
    // @@protoc_insertion_point(special_field:filer_pb.CacheRemoteObjectToLocalClusterResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CacheRemoteObjectToLocalClusterResponse {
    fn default() -> &'a CacheRemoteObjectToLocalClusterResponse {
        <CacheRemoteObjectToLocalClusterResponse as ::protobuf::Message>::default_instance()
    }
}

impl CacheRemoteObjectToLocalClusterResponse {
    pub fn new() -> CacheRemoteObjectToLocalClusterResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Entry>(
            "entry",
            |m: &CacheRemoteObjectToLocalClusterResponse| { &m.entry },
            |m: &mut CacheRemoteObjectToLocalClusterResponse| { &mut m.entry },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CacheRemoteObjectToLocalClusterResponse>(
            "CacheRemoteObjectToLocalClusterResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CacheRemoteObjectToLocalClusterResponse {
    const NAME: &'static str = "CacheRemoteObjectToLocalClusterResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.entry)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.entry.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CacheRemoteObjectToLocalClusterResponse {
        CacheRemoteObjectToLocalClusterResponse::new()
    }

    fn clear(&mut self) {
        self.entry.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CacheRemoteObjectToLocalClusterResponse {
        static instance: CacheRemoteObjectToLocalClusterResponse = CacheRemoteObjectToLocalClusterResponse {
            entry: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CacheRemoteObjectToLocalClusterResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CacheRemoteObjectToLocalClusterResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CacheRemoteObjectToLocalClusterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CacheRemoteObjectToLocalClusterResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bfiler.proto\x12\x08filer_pb\"O\n\x1bLookupDirectoryEntryRequest\
    \x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirectory\x12\x12\n\x04name\
    \x18\x02\x20\x01(\tR\x04name\"E\n\x1cLookupDirectoryEntryResponse\x12%\n\
    \x05entry\x18\x01\x20\x01(\x0b2\x0f.filer_pb.EntryR\x05entry\"\xbe\x01\n\
    \x12ListEntriesRequest\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirecto\
    ry\x12\x16\n\x06prefix\x18\x02\x20\x01(\tR\x06prefix\x12,\n\x11startFrom\
    FileName\x18\x03\x20\x01(\tR\x11startFromFileName\x12.\n\x12inclusiveSta\
    rtFrom\x18\x04\x20\x01(\x08R\x12inclusiveStartFrom\x12\x14\n\x05limit\
    \x18\x05\x20\x01(\rR\x05limit\"<\n\x13ListEntriesResponse\x12%\n\x05entr\
    y\x18\x01\x20\x01(\x0b2\x0f.filer_pb.EntryR\x05entry\"\xc8\x01\n\x0bRemo\
    teEntry\x12!\n\x0cstorage_name\x18\x01\x20\x01(\tR\x0bstorageName\x120\n\
    \x15last_local_sync_ts_ns\x18\x02\x20\x01(\x03R\x11lastLocalSyncTsNs\x12\
    \x20\n\x0cremote_e_tag\x18\x03\x20\x01(\tR\nremoteETag\x12!\n\x0cremote_\
    mtime\x18\x04\x20\x01(\x03R\x0bremoteMtime\x12\x1f\n\x0bremote_size\x18\
    \x05\x20\x01(\x03R\nremoteSize\"\xd5\x03\n\x05Entry\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12!\n\x0cis_directory\x18\x02\x20\x01(\x08\
    R\x0bisDirectory\x12+\n\x06chunks\x18\x03\x20\x03(\x0b2\x13.filer_pb.Fil\
    eChunkR\x06chunks\x128\n\nattributes\x18\x04\x20\x01(\x0b2\x18.filer_pb.\
    FuseAttributesR\nattributes\x129\n\x08extended\x18\x05\x20\x03(\x0b2\x1d\
    .filer_pb.Entry.ExtendedEntryR\x08extended\x12\x20\n\x0chard_link_id\x18\
    \x07\x20\x01(\x0cR\nhardLinkId\x12*\n\x11hard_link_counter\x18\x08\x20\
    \x01(\x05R\x0fhardLinkCounter\x12\x18\n\x07content\x18\t\x20\x01(\x0cR\
    \x07content\x128\n\x0cremote_entry\x18\n\x20\x01(\x0b2\x15.filer_pb.Remo\
    teEntryR\x0bremoteEntry\x12\x14\n\x05quota\x18\x0b\x20\x01(\x03R\x05quot\
    a\x1a;\n\rExtendedEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"D\n\tFullEntry\
    \x12\x10\n\x03dir\x18\x01\x20\x01(\tR\x03dir\x12%\n\x05entry\x18\x02\x20\
    \x01(\x0b2\x0f.filer_pb.EntryR\x05entry\"\x8f\x02\n\x11EventNotification\
    \x12,\n\told_entry\x18\x01\x20\x01(\x0b2\x0f.filer_pb.EntryR\x08oldEntry\
    \x12,\n\tnew_entry\x18\x02\x20\x01(\x0b2\x0f.filer_pb.EntryR\x08newEntry\
    \x12#\n\rdelete_chunks\x18\x03\x20\x01(\x08R\x0cdeleteChunks\x12&\n\x0fn\
    ew_parent_path\x18\x04\x20\x01(\tR\rnewParentPath\x121\n\x15is_from_othe\
    r_cluster\x18\x05\x20\x01(\x08R\x12isFromOtherCluster\x12\x1e\n\nsignatu\
    res\x18\x06\x20\x03(\x05R\nsignatures\"\xe6\x02\n\tFileChunk\x12\x17\n\
    \x07file_id\x18\x01\x20\x01(\tR\x06fileId\x12\x16\n\x06offset\x18\x02\
    \x20\x01(\x03R\x06offset\x12\x12\n\x04size\x18\x03\x20\x01(\x04R\x04size\
    \x12\x14\n\x05mtime\x18\x04\x20\x01(\x03R\x05mtime\x12\x13\n\x05e_tag\
    \x18\x05\x20\x01(\tR\x04eTag\x12$\n\x0esource_file_id\x18\x06\x20\x01(\t\
    R\x0csourceFileId\x12\"\n\x03fid\x18\x07\x20\x01(\x0b2\x10.filer_pb.File\
    IdR\x03fid\x12/\n\nsource_fid\x18\x08\x20\x01(\x0b2\x10.filer_pb.FileIdR\
    \tsourceFid\x12\x1d\n\ncipher_key\x18\t\x20\x01(\x0cR\tcipherKey\x12#\n\
    \ris_compressed\x18\n\x20\x01(\x08R\x0cisCompressed\x12*\n\x11is_chunk_m\
    anifest\x18\x0b\x20\x01(\x08R\x0fisChunkManifest\"@\n\x11FileChunkManife\
    st\x12+\n\x06chunks\x18\x01\x20\x03(\x0b2\x13.filer_pb.FileChunkR\x06chu\
    nks\"X\n\x06FileId\x12\x1b\n\tvolume_id\x18\x01\x20\x01(\rR\x08volumeId\
    \x12\x19\n\x08file_key\x18\x02\x20\x01(\x04R\x07fileKey\x12\x16\n\x06coo\
    kie\x18\x03\x20\x01(\x07R\x06cookie\"\xe8\x02\n\x0eFuseAttributes\x12\
    \x1b\n\tfile_size\x18\x01\x20\x01(\x04R\x08fileSize\x12\x14\n\x05mtime\
    \x18\x02\x20\x01(\x03R\x05mtime\x12\x1b\n\tfile_mode\x18\x03\x20\x01(\rR\
    \x08fileMode\x12\x10\n\x03uid\x18\x04\x20\x01(\rR\x03uid\x12\x10\n\x03gi\
    d\x18\x05\x20\x01(\rR\x03gid\x12\x16\n\x06crtime\x18\x06\x20\x01(\x03R\
    \x06crtime\x12\x12\n\x04mime\x18\x07\x20\x01(\tR\x04mime\x12\x17\n\x07tt\
    l_sec\x18\n\x20\x01(\x05R\x06ttlSec\x12\x1b\n\tuser_name\x18\x0b\x20\x01\
    (\tR\x08userName\x12\x1d\n\ngroup_name\x18\x0c\x20\x03(\tR\tgroupName\
    \x12%\n\x0esymlink_target\x18\r\x20\x01(\tR\rsymlinkTarget\x12\x10\n\x03\
    md5\x18\x0e\x20\x01(\x0cR\x03md5\x12\x12\n\x04rdev\x18\x10\x20\x01(\rR\
    \x04rdev\x12\x14\n\x05inode\x18\x11\x20\x01(\x04R\x05inode\"\x82\x02\n\
    \x12CreateEntryRequest\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirecto\
    ry\x12%\n\x05entry\x18\x02\x20\x01(\x0b2\x0f.filer_pb.EntryR\x05entry\
    \x12\x15\n\x06o_excl\x18\x03\x20\x01(\x08R\x05oExcl\x121\n\x15is_from_ot\
    her_cluster\x18\x04\x20\x01(\x08R\x12isFromOtherCluster\x12\x1e\n\nsigna\
    tures\x18\x05\x20\x03(\x05R\nsignatures\x12=\n\x1bskip_check_parent_dire\
    ctory\x18\x06\x20\x01(\x08R\x18skipCheckParentDirectory\"+\n\x13CreateEn\
    tryResponse\x12\x14\n\x05error\x18\x01\x20\x01(\tR\x05error\"\xac\x01\n\
    \x12UpdateEntryRequest\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirecto\
    ry\x12%\n\x05entry\x18\x02\x20\x01(\x0b2\x0f.filer_pb.EntryR\x05entry\
    \x121\n\x15is_from_other_cluster\x18\x03\x20\x01(\x08R\x12isFromOtherClu\
    ster\x12\x1e\n\nsignatures\x18\x04\x20\x03(\x05R\nsignatures\"\x15\n\x13\
    UpdateEntryResponse\"\x80\x01\n\x14AppendToEntryRequest\x12\x1c\n\tdirec\
    tory\x18\x01\x20\x01(\tR\tdirectory\x12\x1d\n\nentry_name\x18\x02\x20\
    \x01(\tR\tentryName\x12+\n\x06chunks\x18\x03\x20\x03(\x0b2\x13.filer_pb.\
    FileChunkR\x06chunks\"\x17\n\x15AppendToEntryResponse\"\x98\x02\n\x12Del\
    eteEntryRequest\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirectory\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12$\n\x0eis_delete_data\x18\
    \x04\x20\x01(\x08R\x0cisDeleteData\x12!\n\x0cis_recursive\x18\x05\x20\
    \x01(\x08R\x0bisRecursive\x124\n\x16ignore_recursive_error\x18\x06\x20\
    \x01(\x08R\x14ignoreRecursiveError\x121\n\x15is_from_other_cluster\x18\
    \x07\x20\x01(\x08R\x12isFromOtherCluster\x12\x1e\n\nsignatures\x18\x08\
    \x20\x03(\x05R\nsignatures\"+\n\x13DeleteEntryResponse\x12\x14\n\x05erro\
    r\x18\x01\x20\x01(\tR\x05error\"\xba\x01\n\x18AtomicRenameEntryRequest\
    \x12#\n\rold_directory\x18\x01\x20\x01(\tR\x0coldDirectory\x12\x19\n\x08\
    old_name\x18\x02\x20\x01(\tR\x07oldName\x12#\n\rnew_directory\x18\x03\
    \x20\x01(\tR\x0cnewDirectory\x12\x19\n\x08new_name\x18\x04\x20\x01(\tR\
    \x07newName\x12\x1e\n\nsignatures\x18\x05\x20\x03(\x05R\nsignatures\"\
    \x1b\n\x19AtomicRenameEntryResponse\"\xba\x01\n\x18StreamRenameEntryRequ\
    est\x12#\n\rold_directory\x18\x01\x20\x01(\tR\x0coldDirectory\x12\x19\n\
    \x08old_name\x18\x02\x20\x01(\tR\x07oldName\x12#\n\rnew_directory\x18\
    \x03\x20\x01(\tR\x0cnewDirectory\x12\x19\n\x08new_name\x18\x04\x20\x01(\
    \tR\x07newName\x12\x1e\n\nsignatures\x18\x05\x20\x03(\x05R\nsignatures\"\
    \x9a\x01\n\x19StreamRenameEntryResponse\x12\x1c\n\tdirectory\x18\x01\x20\
    \x01(\tR\tdirectory\x12J\n\x12event_notification\x18\x02\x20\x01(\x0b2\
    \x1b.filer_pb.EventNotificationR\x11eventNotification\x12\x13\n\x05ts_ns\
    \x18\x03\x20\x01(\x03R\x04tsNs\"\x89\x02\n\x13AssignVolumeRequest\x12\
    \x14\n\x05count\x18\x01\x20\x01(\x05R\x05count\x12\x1e\n\ncollection\x18\
    \x02\x20\x01(\tR\ncollection\x12\x20\n\x0breplication\x18\x03\x20\x01(\t\
    R\x0breplication\x12\x17\n\x07ttl_sec\x18\x04\x20\x01(\x05R\x06ttlSec\
    \x12\x1f\n\x0bdata_center\x18\x05\x20\x01(\tR\ndataCenter\x12\x12\n\x04p\
    ath\x18\x06\x20\x01(\tR\x04path\x12\x12\n\x04rack\x18\x07\x20\x01(\tR\
    \x04rack\x12\x1b\n\tdata_node\x18\t\x20\x01(\tR\x08dataNode\x12\x1b\n\td\
    isk_type\x18\x08\x20\x01(\tR\x08diskType\"\xe1\x01\n\x14AssignVolumeResp\
    onse\x12\x17\n\x07file_id\x18\x01\x20\x01(\tR\x06fileId\x12\x14\n\x05cou\
    nt\x18\x04\x20\x01(\x05R\x05count\x12\x12\n\x04auth\x18\x05\x20\x01(\tR\
    \x04auth\x12\x1e\n\ncollection\x18\x06\x20\x01(\tR\ncollection\x12\x20\n\
    \x0breplication\x18\x07\x20\x01(\tR\x0breplication\x12\x14\n\x05error\
    \x18\x08\x20\x01(\tR\x05error\x12.\n\x08location\x18\t\x20\x01(\x0b2\x12\
    .filer_pb.LocationR\x08location\"4\n\x13LookupVolumeRequest\x12\x1d\n\nv\
    olume_ids\x18\x01\x20\x03(\tR\tvolumeIds\"=\n\tLocations\x120\n\tlocatio\
    ns\x18\x01\x20\x03(\x0b2\x12.filer_pb.LocationR\tlocations\"X\n\x08Locat\
    ion\x12\x10\n\x03url\x18\x01\x20\x01(\tR\x03url\x12\x1d\n\npublic_url\
    \x18\x02\x20\x01(\tR\tpublicUrl\x12\x1b\n\tgrpc_port\x18\x03\x20\x01(\rR\
    \x08grpcPort\"\xc3\x01\n\x14LookupVolumeResponse\x12U\n\rlocations_map\
    \x18\x01\x20\x03(\x0b20.filer_pb.LookupVolumeResponse.LocationsMapEntryR\
    \x0clocationsMap\x1aT\n\x11LocationsMapEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12)\n\x05value\x18\x02\x20\x01(\x0b2\x13.filer_pb.L\
    ocationsR\x05value:\x028\x01\"\x20\n\nCollection\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\"{\n\x15CollectionListRequest\x124\n\x16include\
    _normal_volumes\x18\x01\x20\x01(\x08R\x14includeNormalVolumes\x12,\n\x12\
    include_ec_volumes\x18\x02\x20\x01(\x08R\x10includeEcVolumes\"P\n\x16Col\
    lectionListResponse\x126\n\x0bcollections\x18\x01\x20\x03(\x0b2\x14.file\
    r_pb.CollectionR\x0bcollections\"9\n\x17DeleteCollectionRequest\x12\x1e\
    \n\ncollection\x18\x01\x20\x01(\tR\ncollection\"\x1a\n\x18DeleteCollecti\
    onResponse\"\x84\x01\n\x11StatisticsRequest\x12\x20\n\x0breplication\x18\
    \x01\x20\x01(\tR\x0breplication\x12\x1e\n\ncollection\x18\x02\x20\x01(\t\
    R\ncollection\x12\x10\n\x03ttl\x18\x03\x20\x01(\tR\x03ttl\x12\x1b\n\tdis\
    k_type\x18\x04\x20\x01(\tR\x08diskType\"o\n\x12StatisticsResponse\x12\
    \x1d\n\ntotal_size\x18\x04\x20\x01(\x04R\ttotalSize\x12\x1b\n\tused_size\
    \x18\x05\x20\x01(\x04R\x08usedSize\x12\x1d\n\nfile_count\x18\x06\x20\x01\
    (\x04R\tfileCount\"F\n\x0bPingRequest\x12\x16\n\x06target\x18\x01\x20\
    \x01(\tR\x06target\x12\x1f\n\x0btarget_type\x18\x02\x20\x01(\tR\ntargetT\
    ype\"z\n\x0cPingResponse\x12\"\n\rstart_time_ns\x18\x01\x20\x01(\x03R\
    \x0bstartTimeNs\x12$\n\x0eremote_time_ns\x18\x02\x20\x01(\x03R\x0cremote\
    TimeNs\x12\x20\n\x0cstop_time_ns\x18\x03\x20\x01(\x03R\nstopTimeNs\"\x1e\
    \n\x1cGetFilerConfigurationRequest\"\x9e\x03\n\x1dGetFilerConfigurationR\
    esponse\x12\x18\n\x07masters\x18\x01\x20\x03(\tR\x07masters\x12\x20\n\
    \x0breplication\x18\x02\x20\x01(\tR\x0breplication\x12\x1e\n\ncollection\
    \x18\x03\x20\x01(\tR\ncollection\x12\x15\n\x06max_mb\x18\x04\x20\x01(\rR\
    \x05maxMb\x12\x1f\n\x0bdir_buckets\x18\x05\x20\x01(\tR\ndirBuckets\x12\
    \x16\n\x06cipher\x18\x07\x20\x01(\x08R\x06cipher\x12\x1c\n\tsignature\
    \x18\x08\x20\x01(\x05R\tsignature\x12'\n\x0fmetrics_address\x18\t\x20\
    \x01(\tR\x0emetricsAddress\x120\n\x14metrics_interval_sec\x18\n\x20\x01(\
    \x05R\x12metricsIntervalSec\x12\x18\n\x07version\x18\x0b\x20\x01(\tR\x07\
    version\x12\x1d\n\ncluster_id\x18\x0c\x20\x01(\tR\tclusterId\x12\x1f\n\
    \x0bfiler_group\x18\r\x20\x01(\tR\nfilerGroup\"\xf2\x01\n\x18SubscribeMe\
    tadataRequest\x12\x1f\n\x0bclient_name\x18\x01\x20\x01(\tR\nclientName\
    \x12\x1f\n\x0bpath_prefix\x18\x02\x20\x01(\tR\npathPrefix\x12\x19\n\x08s\
    ince_ns\x18\x03\x20\x01(\x03R\x07sinceNs\x12\x1c\n\tsignature\x18\x04\
    \x20\x01(\x05R\tsignature\x12#\n\rpath_prefixes\x18\x06\x20\x03(\tR\x0cp\
    athPrefixes\x12\x1b\n\tclient_id\x18\x07\x20\x01(\x05R\x08clientId\x12\
    \x19\n\x08until_ns\x18\x08\x20\x01(\x03R\x07untilNs\"\x9a\x01\n\x19Subsc\
    ribeMetadataResponse\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirectory\
    \x12J\n\x12event_notification\x18\x02\x20\x01(\x0b2\x1b.filer_pb.EventNo\
    tificationR\x11eventNotification\x12\x13\n\x05ts_ns\x18\x03\x20\x01(\x03\
    R\x04tsNs\"a\n\x08LogEntry\x12\x13\n\x05ts_ns\x18\x01\x20\x01(\x03R\x04t\
    sNs\x12,\n\x12partition_key_hash\x18\x02\x20\x01(\x05R\x10partitionKeyHa\
    sh\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"e\n\x14KeepConnected\
    Request\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1b\n\tgrpc_po\
    rt\x18\x02\x20\x01(\rR\x08grpcPort\x12\x1c\n\tresources\x18\x03\x20\x03(\
    \tR\tresources\"\x17\n\x15KeepConnectedResponse\"1\n\x13LocateBrokerRequ\
    est\x12\x1a\n\x08resource\x18\x01\x20\x01(\tR\x08resource\"\xcd\x01\n\
    \x14LocateBrokerResponse\x12\x14\n\x05found\x18\x01\x20\x01(\x08R\x05fou\
    nd\x12E\n\tresources\x18\x02\x20\x03(\x0b2'.filer_pb.LocateBrokerRespons\
    e.ResourceR\tresources\x1aX\n\x08Resource\x12%\n\x0egrpc_addresses\x18\
    \x01\x20\x01(\tR\rgrpcAddresses\x12%\n\x0eresource_count\x18\x02\x20\x01\
    (\x05R\rresourceCount\"\x20\n\x0cKvGetRequest\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x0cR\x03key\";\n\rKvGetResponse\x12\x14\n\x05value\x18\x01\x20\
    \x01(\x0cR\x05value\x12\x14\n\x05error\x18\x02\x20\x01(\tR\x05error\"6\n\
    \x0cKvPutRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x0cR\x05value\"%\n\rKvPutResponse\x12\x14\n\
    \x05error\x18\x01\x20\x01(\tR\x05error\"\xbd\x03\n\tFilerConf\x12\x18\n\
    \x07version\x18\x01\x20\x01(\x05R\x07version\x12:\n\tlocations\x18\x02\
    \x20\x03(\x0b2\x1c.filer_pb.FilerConf.PathConfR\tlocations\x1a\xd9\x02\n\
    \x08PathConf\x12'\n\x0flocation_prefix\x18\x01\x20\x01(\tR\x0elocationPr\
    efix\x12\x1e\n\ncollection\x18\x02\x20\x01(\tR\ncollection\x12\x20\n\x0b\
    replication\x18\x03\x20\x01(\tR\x0breplication\x12\x10\n\x03ttl\x18\x04\
    \x20\x01(\tR\x03ttl\x12\x1b\n\tdisk_type\x18\x05\x20\x01(\tR\x08diskType\
    \x12\x14\n\x05fsync\x18\x06\x20\x01(\x08R\x05fsync\x12.\n\x13volume_grow\
    th_count\x18\x07\x20\x01(\rR\x11volumeGrowthCount\x12\x1b\n\tread_only\
    \x18\x08\x20\x01(\x08R\x08readOnly\x12\x1f\n\x0bdata_center\x18\t\x20\
    \x01(\tR\ndataCenter\x12\x12\n\x04rack\x18\n\x20\x01(\tR\x04rack\x12\x1b\
    \n\tdata_node\x18\x0b\x20\x01(\tR\x08dataNode\"Z\n&CacheRemoteObjectToLo\
    calClusterRequest\x12\x1c\n\tdirectory\x18\x01\x20\x01(\tR\tdirectory\
    \x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"P\n'CacheRemoteObjectToL\
    ocalClusterResponse\x12%\n\x05entry\x18\x01\x20\x01(\x0b2\x0f.filer_pb.E\
    ntryR\x05entry2\x82\x0f\n\x0cSeaweedFiler\x12g\n\x14LookupDirectoryEntry\
    \x12%.filer_pb.LookupDirectoryEntryRequest\x1a&.filer_pb.LookupDirectory\
    EntryResponse\"\0\x12N\n\x0bListEntries\x12\x1c.filer_pb.ListEntriesRequ\
    est\x1a\x1d.filer_pb.ListEntriesResponse\"\00\x01\x12L\n\x0bCreateEntry\
    \x12\x1c.filer_pb.CreateEntryRequest\x1a\x1d.filer_pb.CreateEntryRespons\
    e\"\0\x12L\n\x0bUpdateEntry\x12\x1c.filer_pb.UpdateEntryRequest\x1a\x1d.\
    filer_pb.UpdateEntryResponse\"\0\x12R\n\rAppendToEntry\x12\x1e.filer_pb.\
    AppendToEntryRequest\x1a\x1f.filer_pb.AppendToEntryResponse\"\0\x12L\n\
    \x0bDeleteEntry\x12\x1c.filer_pb.DeleteEntryRequest\x1a\x1d.filer_pb.Del\
    eteEntryResponse\"\0\x12^\n\x11AtomicRenameEntry\x12\".filer_pb.AtomicRe\
    nameEntryRequest\x1a#.filer_pb.AtomicRenameEntryResponse\"\0\x12`\n\x11S\
    treamRenameEntry\x12\".filer_pb.StreamRenameEntryRequest\x1a#.filer_pb.S\
    treamRenameEntryResponse\"\00\x01\x12O\n\x0cAssignVolume\x12\x1d.filer_p\
    b.AssignVolumeRequest\x1a\x1e.filer_pb.AssignVolumeResponse\"\0\x12O\n\
    \x0cLookupVolume\x12\x1d.filer_pb.LookupVolumeRequest\x1a\x1e.filer_pb.L\
    ookupVolumeResponse\"\0\x12U\n\x0eCollectionList\x12\x1f.filer_pb.Collec\
    tionListRequest\x1a\x20.filer_pb.CollectionListResponse\"\0\x12[\n\x10De\
    leteCollection\x12!.filer_pb.DeleteCollectionRequest\x1a\".filer_pb.Dele\
    teCollectionResponse\"\0\x12I\n\nStatistics\x12\x1b.filer_pb.StatisticsR\
    equest\x1a\x1c.filer_pb.StatisticsResponse\"\0\x127\n\x04Ping\x12\x15.fi\
    ler_pb.PingRequest\x1a\x16.filer_pb.PingResponse\"\0\x12j\n\x15GetFilerC\
    onfiguration\x12&.filer_pb.GetFilerConfigurationRequest\x1a'.filer_pb.Ge\
    tFilerConfigurationResponse\"\0\x12`\n\x11SubscribeMetadata\x12\".filer_\
    pb.SubscribeMetadataRequest\x1a#.filer_pb.SubscribeMetadataResponse\"\00\
    \x01\x12e\n\x16SubscribeLocalMetadata\x12\".filer_pb.SubscribeMetadataRe\
    quest\x1a#.filer_pb.SubscribeMetadataResponse\"\00\x01\x12V\n\rKeepConne\
    cted\x12\x1e.filer_pb.KeepConnectedRequest\x1a\x1f.filer_pb.KeepConnecte\
    dResponse\"\0(\x010\x01\x12O\n\x0cLocateBroker\x12\x1d.filer_pb.LocateBr\
    okerRequest\x1a\x1e.filer_pb.LocateBrokerResponse\"\0\x12:\n\x05KvGet\
    \x12\x16.filer_pb.KvGetRequest\x1a\x17.filer_pb.KvGetResponse\"\0\x12:\n\
    \x05KvPut\x12\x16.filer_pb.KvPutRequest\x1a\x17.filer_pb.KvPutResponse\"\
    \0\x12\x88\x01\n\x1fCacheRemoteObjectToLocalCluster\x120.filer_pb.CacheR\
    emoteObjectToLocalClusterRequest\x1a1.filer_pb.CacheRemoteObjectToLocalC\
    lusterResponse\"\0B\x1e\n\x10seaweedfs.clientB\nFilerProtob\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(57);
            messages.push(LookupDirectoryEntryRequest::generated_message_descriptor_data());
            messages.push(LookupDirectoryEntryResponse::generated_message_descriptor_data());
            messages.push(ListEntriesRequest::generated_message_descriptor_data());
            messages.push(ListEntriesResponse::generated_message_descriptor_data());
            messages.push(RemoteEntry::generated_message_descriptor_data());
            messages.push(Entry::generated_message_descriptor_data());
            messages.push(FullEntry::generated_message_descriptor_data());
            messages.push(EventNotification::generated_message_descriptor_data());
            messages.push(FileChunk::generated_message_descriptor_data());
            messages.push(FileChunkManifest::generated_message_descriptor_data());
            messages.push(FileId::generated_message_descriptor_data());
            messages.push(FuseAttributes::generated_message_descriptor_data());
            messages.push(CreateEntryRequest::generated_message_descriptor_data());
            messages.push(CreateEntryResponse::generated_message_descriptor_data());
            messages.push(UpdateEntryRequest::generated_message_descriptor_data());
            messages.push(UpdateEntryResponse::generated_message_descriptor_data());
            messages.push(AppendToEntryRequest::generated_message_descriptor_data());
            messages.push(AppendToEntryResponse::generated_message_descriptor_data());
            messages.push(DeleteEntryRequest::generated_message_descriptor_data());
            messages.push(DeleteEntryResponse::generated_message_descriptor_data());
            messages.push(AtomicRenameEntryRequest::generated_message_descriptor_data());
            messages.push(AtomicRenameEntryResponse::generated_message_descriptor_data());
            messages.push(StreamRenameEntryRequest::generated_message_descriptor_data());
            messages.push(StreamRenameEntryResponse::generated_message_descriptor_data());
            messages.push(AssignVolumeRequest::generated_message_descriptor_data());
            messages.push(AssignVolumeResponse::generated_message_descriptor_data());
            messages.push(LookupVolumeRequest::generated_message_descriptor_data());
            messages.push(Locations::generated_message_descriptor_data());
            messages.push(Location::generated_message_descriptor_data());
            messages.push(LookupVolumeResponse::generated_message_descriptor_data());
            messages.push(Collection::generated_message_descriptor_data());
            messages.push(CollectionListRequest::generated_message_descriptor_data());
            messages.push(CollectionListResponse::generated_message_descriptor_data());
            messages.push(DeleteCollectionRequest::generated_message_descriptor_data());
            messages.push(DeleteCollectionResponse::generated_message_descriptor_data());
            messages.push(StatisticsRequest::generated_message_descriptor_data());
            messages.push(StatisticsResponse::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(GetFilerConfigurationRequest::generated_message_descriptor_data());
            messages.push(GetFilerConfigurationResponse::generated_message_descriptor_data());
            messages.push(SubscribeMetadataRequest::generated_message_descriptor_data());
            messages.push(SubscribeMetadataResponse::generated_message_descriptor_data());
            messages.push(LogEntry::generated_message_descriptor_data());
            messages.push(KeepConnectedRequest::generated_message_descriptor_data());
            messages.push(KeepConnectedResponse::generated_message_descriptor_data());
            messages.push(LocateBrokerRequest::generated_message_descriptor_data());
            messages.push(LocateBrokerResponse::generated_message_descriptor_data());
            messages.push(KvGetRequest::generated_message_descriptor_data());
            messages.push(KvGetResponse::generated_message_descriptor_data());
            messages.push(KvPutRequest::generated_message_descriptor_data());
            messages.push(KvPutResponse::generated_message_descriptor_data());
            messages.push(FilerConf::generated_message_descriptor_data());
            messages.push(CacheRemoteObjectToLocalClusterRequest::generated_message_descriptor_data());
            messages.push(CacheRemoteObjectToLocalClusterResponse::generated_message_descriptor_data());
            messages.push(locate_broker_response::Resource::generated_message_descriptor_data());
            messages.push(filer_conf::PathConf::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(0);
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
